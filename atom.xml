<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Ramsey&#39;s Blog</title>
  <subtitle>iOS 攻城狮</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2017-01-13T08:23:12.000Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Ramsey</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>iOS Runtime 机制</title>
    <link href="http://yoursite.com/2017/01/09/iOS-Runtime/"/>
    <id>http://yoursite.com/2017/01/09/iOS-Runtime/</id>
    <published>2017-01-09T08:15:55.000Z</published>
    <updated>2017-01-13T08:23:12.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>上一篇文章讨论了 <code>Swift</code> 下如何实现 <code>Runtime</code> 的一些实际应用，那么这篇文章索性了解下 <code>iOS</code> 的 <code>Runtime</code> 机制。</p>
<p>虽然 <code>Swift</code> 作为一门编程语言是不具有动态性的，使用 <code>Swift</code> 编写的代码，在编译时就确定了调用那个函数，而不是 <code>Objective-C</code> 的运行时发消息，它采用的是类似 <code>C++</code> 的 <code>vtable</code>，这样的机制确保了 <code>Swift</code> 代码运行的更快，然而由于 <code>iOS</code> 的核心框架 <code>Cocoa</code> 是使用 <code>Objective-C</code> 编写的，而 <code>Swift</code> 为了向 <code>Objective-C</code> 兼容，也做了很多妥协，因此还是有必要了解下 <code>Objective-C</code> 的 <code>Runtime</code> 机制。</p>
<a id="more"></a>
<p>学习 <code>Runtime</code> 最好的方法当然是看官方文档和读源码，所以这里就先把地址贴出来。</p>
<p><a href="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Introduction/Introduction.html" target="_blank" rel="external">Objective-C Runtime Programming Guide</a></p>
<p><a href="http://opensource.apple.com/tarballs/objc4/objc4-680.tar.gz" target="_blank" rel="external">源码下载</a></p>
<h2 id="Runtime-简介"><a href="#Runtime-简介" class="headerlink" title="Runtime 简介"></a>Runtime 简介</h2><p><code>Runtime</code> 又叫运行时，是一套底层的 <code>C</code> 语言 <code>API</code>，其为 <code>iOS</code> 内部的核心之一，我们平时编写的 <code>Objective-C</code> 代码，底层都是基于它来实现的。</p>
<p><code>Objective-C</code> 是动态语言，这意味着它不仅需要一个编译器，也需要一个运行时系统来动态得创建类和对象、进行消息传递和转发。而 <code>Runtime</code> 系统扮演了 <code>Objective-C</code> 语言的一个操作系统的角色，也正是因为它，<code>Objective-C</code> 语言才能那样运行。</p>
<h3 id="Runtime-版本和平台"><a href="#Runtime-版本和平台" class="headerlink" title="Runtime 版本和平台"></a><code>Runtime</code> 版本和平台</h3><p>事实上有两个 <code>Runtime</code> 版本，<code>Legacy</code> 和 <code>Modern</code>，他们运行在不同的平台中，目前我们常用的平台都使用的是 <code>Modern</code> 版本。</p>
<blockquote>
<ul>
<li><p>运行在 iPhone 上的应用以及运行在 OS X v10.5 系统上的 64-bit 的程序使用的 <code>Modern</code> 版本的 <code>Runtime</code></p>
</li>
<li><p>其他的 32-bit 程序使用的 <code>Legacy</code> 版本。</p>
</li>
</ul>
</blockquote>
<p>两个版本最显著的区别在于在 <code>Modern</code> 版本中，实例变量是不那么”易碎的”(non-fragile)</p>
<ul>
<li><p>在 <code>Legacy</code> 的<code>Runtime</code> 中，如果你改变了类中实例变量的布局，那么必须重新编译所以继承自此类的子类。</p>
</li>
<li><p>在 <code>Modern</code> 的 <code>Runtime</code> 中，则不需要重新编译他的子类。</p>
</li>
</ul>
<p>此外,现行版本支持声明 <code>property</code> 的 <code>synthesis</code> 属性器。</p>
<h3 id="Objective-C-与-Runtime-的交互"><a href="#Objective-C-与-Runtime-的交互" class="headerlink" title="Objective-C 与 Runtime 的交互"></a><code>Objective-C</code> 与 <code>Runtime</code> 的交互</h3><p><code>Objective-C</code> 在三个层面上与 <code>Runtime</code> 系统进行交互：</p>
<p><img src="https://raw.githubusercontent.com/seamusapple/MarkDownPics/master/iOS-Runtime/RuntimeCommunication.jpg" alt=""></p>
<blockquote>
<p><em>参考自<a href="http://www.jianshu.com/p/9d649ce6d0b8#" target="_blank" rel="external">神经病院Objective-C Runtime入院第一天——isa和Class</a></em></p>
</blockquote>
<h4 id="通过-Objective-C-源代码"><a href="#通过-Objective-C-源代码" class="headerlink" title="通过 Objective-C 源代码"></a>通过 <code>Objective-C</code> 源代码</h4><p>多数情况我们只需要编写 <code>Objective-C</code> 代码即可，<code>Runtime</code> 系统自动在幕后搞定一切，我们调用方法，编译器会将 <code>Objective-C</code> 代码转换成运行时代码，在运行时确定数据结构和函数。这些数据结构会捕获类，分类和协议生命中的信息；这些信息包括类和协议对象，方法选择器(<code>method selector</code>)、实例变量模板和从源码中提炼的其他信息。运行时的核心原则是发送消息。</p>
<h4 id="通过-NSObject-方法"><a href="#通过-NSObject-方法" class="headerlink" title="通过 NSObject 方法"></a>通过 <code>NSObject</code> 方法</h4><p>Cocoa 中大多数的类都是 <code>NSObject</code> 类的子类，这些类都继承了 <code>NSObject</code> 类的方法，唯一的例外是 <code>NSProxy</code> 类，它和 <code>NSObject</code> 一样，是一个基类，是专门用于实现代理对象的类。</p>
<p>有的 <code>NSObject</code> 中的方法起到了抽象接口的作用，比如 <code>description</code> 方法，<code>NSObject</code> 类并不知道类中都有什么信息，所以他只会返回包含这个对象名字和地址的字符串，对于他的子类，则需要你重载它并为你定义的类提供描述内容。<code>NSObject</code> 还有些方法能在运行时获得类的信息，并检查一些特性，比如 <code>class</code> 返回对象的类；<code>isKindOfClass:</code> 和 <code>isMemberOfClass:</code> 则检查对象是否在指定的类继承体系中；<code>respondsToSelector:</code> 检查对象能否响应指定的消息；<code>conformsToProtocol:</code> 检查对象是否实现了指定协议类的方法；<code>methodForSelector:</code> 则返回指定方法实现的地址。</p>
<blockquote>
<p>这里需要注意的是在 <code>Objective-C</code> 中，<code>NSObject</code> 不仅是类名，也是个协议名，<code>NSObject</code> 作为根协议，定义了一些接口方法，而 <code>NSObject</code> 类遵守这个协议，并且在内部实现了这些方法，包括上段提到的那些方法，而在 <code>Swift</code> 中，根协议 <code>NSObject</code> 改名为 <code>NSObjectProtocol</code>。</p>
</blockquote>
<h4 id="通过-Runtime-的方法"><a href="#通过-Runtime-的方法" class="headerlink" title="通过 Runtime 的方法"></a>通过 <code>Runtime</code> 的方法</h4><p><code>Runtime</code> 系统是一个由一系列函数和数据结构组成，具有公共接口的动态共享库。头文件存放于 /usr/include/objc 目录下。许多函数允许你用纯 <code>C</code> 代码来重复实现 <code>Objective-C</code> 中同样的功能。虽然有一些方法构成了 <code>NSObject</code> 类的基础，但是你在写 <code>Objective-C</code> 代码时一般不会直接用到这些函数的，除非是写一些 <code>Objective-C</code> 与其他语言的桥接或是底层的 <code>debug</code> 工作。在 <a href="https://developer.apple.com/library/mac/documentation/Cocoa/Reference/ObjCRuntimeRef/index.html" target="_blank" rel="external">Objective-C Runtime Reference</a> 中有对 <code>Runtime</code> 函数的详细文档。</p>
<h3 id="Cocoa-对象"><a href="#Cocoa-对象" class="headerlink" title="Cocoa 对象"></a>Cocoa 对象</h3><p>既然说到了 <code>NSObject</code>，那么也顺便了解下整个 Cocoa 框架。 Cocoa 框架是 iOS 程序的基础，它是OS X和 iOS操作系统的程序的运行环境。在 Cocoa 众多框架中，最重要的两个基础框架是： <code>Foundation</code> 和 <code>UIKit</code>。<code>Foundation</code> 和界面无关，也可以说和界面无关的类基本是<code>Foundation</code> 框架的，和界面相关的是 <code>UIKit</code> 框架。这两个框架在系统中处于的位置如图：</p>
<p><img src="https://raw.githubusercontent.com/seamusapple/MarkDownPics/master/iOS-Runtime/iOSFoundation.jpg" alt=""></p>
<h4 id="Foundation-框架"><a href="#Foundation-框架" class="headerlink" title="Foundation 框架"></a><code>Foundation</code> 框架</h4><p>下面这几张图描述了 <code>Foundation</code> 框架的类组织架构图，图中灰色的是 iOS 不支持的，灰色部分是 OS X 系统的。</p>
<p><img src="https://raw.githubusercontent.com/seamusapple/MarkDownPics/master/iOS-Runtime/CocoaFoundationOne.jpg" alt=""></p>
<p><img src="https://raw.githubusercontent.com/seamusapple/MarkDownPics/master/iOS-Runtime/CocoaFoundationTwo.jpg" alt=""></p>
<p><img src="https://raw.githubusercontent.com/seamusapple/MarkDownPics/master/iOS-Runtime/CocoaFoundationThree.jpg" alt=""></p>
<p>将上图Foundation框架中的类进行逻辑分类如下：</p>
<ul>
<li><p>值对象</p>
</li>
<li><p>集合 </p>
</li>
<li><p>操作系统服务，包括下面三个：</p>
<ul>
<li><p>文件系统和URL   </p>
</li>
<li><p>进程间通讯  </p>
</li>
<li><p>线程和子任务。 </p>
</li>
<li><p>通知</p>
</li>
<li><p>归档和序列化</p>
</li>
<li><p>表达式和条件判断</p>
</li>
<li><p>Objective-C语言服务</p>
</li>
</ul>
</li>
</ul>
<h4 id="UIKit-框架"><a href="#UIKit-框架" class="headerlink" title="UIKit 框架"></a><code>UIKit</code> 框架</h4><p>应用程序可以通过三种方式使用 <code>UIKit</code> 创建界面:</p>
<ul>
<li><p>在用户界面工具（interface Buidler）从对象库里拖拽窗口，视图或者其他的对象使用。</p>
</li>
<li><p>用代码创建</p>
</li>
<li><p>通过继承 <code>UIView</code> 类或间接继承 <code>UIView</code> 类实现自定义用户界面</p>
</li>
</ul>
<p>下面这几张图描述了框架类组织架构：</p>
<p><img src="https://raw.githubusercontent.com/seamusapple/MarkDownPics/master/iOS-Runtime/CocoaUIKit.jpg" alt=""></p>
<p>在图中可以看出，<code>UIResponder</code> 类是图中最大分支的根类，<code>UIResponder</code> 为处理响应事件和响应链 定义了界面和默认行为。</p>
<p>当用户用手指滚动列表或者在虚拟键盘上输入时，<code>UIKit</code> 就生成时间传送给<code>UIResponder</code> 响应链，直到链中有对象处理这个事件。相应的核心对象，比如：<code>UIApplication</code>, <code>UIWindow</code>, <code>UIView</code> 都直接或间接的从 <code>UIResponder</code> 继承。</p>
<blockquote>
<p>本段参考 <a href="http://blog.csdn.net/totogo2010/article/details/8081253" target="_blank" rel="external"> Cocoa 框架 For iOS(一) 框架的介绍，Objectivie-C运行时能力的解析等</a></p>
</blockquote>
<h3 id="NSObject-起源"><a href="#NSObject-起源" class="headerlink" title="NSObject 起源"></a><code>NSObject</code> 起源</h3><p>从上一小节我们知道 <code>NSObject</code> 是 Cocoa 框架的两大基类之一，那么 <code>NSObject</code> 的结构是怎样的呢？了解 <code>NSObject</code> 的结构有助于我们了解整个 <code>Objective-C</code> 的运行时消息机制有很大的帮助，那么我们直接去看源码。</p>
<p>在 <code>NSObject</code> 的头文件中，看到 <code>NSObject</code> 的定义如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">@interface NSObject &lt;NSObject&gt; &#123;</div><div class="line">    Class isa  OBJC_ISA_AVAILABILITY;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>首先我们看到 <code>NSObject</code> 遵循 <code>NSObject</code> 协议，其次，可以看到他包含一个 <code>Class</code> 类型的名字为 <code>isa</code> 的属性，那么 <code>Class</code> 又是什么鬼？继续找，找到 <code>objc</code> 的头文件中找到：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> objc_class *Class</div><div class="line"></div><div class="line"><span class="keyword">struct</span> objc_class &#123;</div><div class="line">    Class isa  OBJC_ISA_AVAILABILITY;</div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">if</span> !__OBJC2__</span></div><div class="line">    Class super_class                                        OBJC2_UNAVAILABLE;</div><div class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *name                                         OBJC2_UNAVAILABLE;</div><div class="line">    <span class="keyword">long</span> version                                             OBJC2_UNAVAILABLE;</div><div class="line">    <span class="keyword">long</span> info                                                OBJC2_UNAVAILABLE;</div><div class="line">    <span class="keyword">long</span> instance_size                                       OBJC2_UNAVAILABLE;</div><div class="line">    <span class="keyword">struct</span> objc_ivar_list *ivars                             OBJC2_UNAVAILABLE;</div><div class="line">    <span class="keyword">struct</span> objc_method_list **methodLists                    OBJC2_UNAVAILABLE;</div><div class="line">    <span class="keyword">struct</span> objc_cache *cache                                 OBJC2_UNAVAILABLE;</div><div class="line">    <span class="keyword">struct</span> objc_protocol_list *protocols                     OBJC2_UNAVAILABLE;</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line"></div><div class="line">&#125; OBJC2_UNAVAILABLE;</div></pre></td></tr></table></figure>
<p>从上面的源码看到， <code>Class</code> 是一个指向 <code>objc_class</code> 结构体的指针，在 <code>Objective-C</code> 2.0 之前，<code>objc_class</code> 结构体包含的信息我们可以从源码中看到，<code>Objective-C</code> 2.0 的头文件虽然没暴露出<code>objc_class</code> 结构体更详细的设计，我们依然可以从 <code>Objective-C</code> 1.0 的定义中小窥端倪，我们首先简写一些，用更 <code>C</code> 的方式去除掉一些不必要的东西：</p>
<blockquote>
<p>注：可以找到 <code>Objective-C</code> 2.0 中 <code>objc-class</code> 的结构，但本篇以 <code>Objective-C</code> 1.0 为例。</p>
<p>如果想了解 <code>Objective-C</code> 2.0 中的 <code>Class</code> 和 <code>isa</code>，请移步阅读<a href="http://www.jianshu.com/p/9d649ce6d0b8#" target="_blank" rel="external">神经病院Objective-C Runtime入院第一天——isa和Class</a></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> NSObject &#123;</div><div class="line">	objc_class *isa</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">struct</span> objc_class &#123;</div><div class="line">	Class isa </div><div class="line">	</div><div class="line">	Class super_class                                      </div><div class="line">	</div><div class="line">	<span class="keyword">const</span> <span class="keyword">char</span> *name</div><div class="line">	</div><div class="line">	<span class="keyword">long</span> version                        </div><div class="line">	<span class="keyword">long</span> info                                      </div><div class="line">	</div><div class="line">	<span class="keyword">long</span> instance_size                         </div><div class="line">	<span class="keyword">struct</span> objc_ivar_list *ivars               </div><div class="line">	<span class="keyword">struct</span> objc_method_list **methodLists      </div><div class="line">	</div><div class="line">	<span class="keyword">struct</span> objc_cache *cache              </div><div class="line">	<span class="keyword">struct</span> objc_protocol_list *protocols                  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>现在就很清楚了， <code>objc_class</code> 结构体中，还有一个 <code>isa</code> 指针，这里的 <code>isa</code> 指针指向的是元类对象(metaclass object)，为什么会有这么一个东西呢？ <code>Objective-C</code> 类本身也是个对象(类对象)，为了处理类和对象的关系，<code>Runtime</code> 库创建了一种叫做元类 (Meta Class) 的东西，类对象所属类型就叫做元类，它用来表述类对象本身所具备的元数据。这些数据包括类的版本，名称，类方法等。我们用的类方法就定义于此处，因为这些方法可以理解成类对象的实例方法。所有的元类对象都指向 <code>NSObject</code> 的元类对象，到头来还是 <code>NSObject</code>。 每个类仅有一个类对象，而每个类对象仅有一个与之相关的元类。元类的概念有点不好理解，没关系，我们先看其他的信息。</p>
<p><code>objc_class</code> 结构体中定义了第二个成员变量 <code>Class super_class</code>，它是指向父类的类对象。 剩下还包含一些运行时需要的类名，版本信息等。剩下还有四个结构体，其中 <code>ivars</code> 是一个指向 <code>objc_ivar_list</code> 结构体的指针， <code>methodLists</code> 是指向 <code>objc_method_list</code> 指针的指针， <code>cache</code> 是一个指向 <code>objc_cache</code> 结构体的指针， <code>protocols</code> 是一个指向 <code>objc_protocol_list</code> 结构体的指针。由于 <code>ivars</code> 和 <code>methodLists</code> 的特性，一个是指向结构体的指针，一个是指向结构体指针的指针，这也就解释了为何类可以动态的添加成员方法而不能添加属性。下面我们来分别看下这四个结构体的具体实现。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> objc_ivar_list &#123;</div><div class="line">    <span class="keyword">int</span> ivar_count                                           OBJC2_UNAVAILABLE;</div><div class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __LP64__</span></div><div class="line">    <span class="keyword">int</span> space                                                OBJC2_UNAVAILABLE;</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line">    <span class="comment">/* variable length structure */</span></div><div class="line">    <span class="keyword">struct</span> objc_ivar ivar_list[<span class="number">1</span>]                            OBJC2_UNAVAILABLE;</div><div class="line">&#125;                                                            OBJC2_UNAVAILABLE;</div><div class="line"></div><div class="line"><span class="keyword">struct</span> objc_method_list &#123;</div><div class="line">    <span class="keyword">struct</span> objc_method_list *obsolete                        OBJC2_UNAVAILABLE;</div><div class="line"></div><div class="line">    <span class="keyword">int</span> method_count                                         OBJC2_UNAVAILABLE;</div><div class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __LP64__</span></div><div class="line">    <span class="keyword">int</span> space                                                OBJC2_UNAVAILABLE;</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line">    <span class="comment">/* variable length structure */</span></div><div class="line">    <span class="keyword">struct</span> objc_method method_list[<span class="number">1</span>]                        OBJC2_UNAVAILABLE;</div><div class="line">&#125;                                                            OBJC2_UNAVAILABLE;</div><div class="line"></div><div class="line"><span class="keyword">struct</span> objc_cache &#123;</div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> mask <span class="comment">/* total = mask + 1 */</span>                 OBJC2_UNAVAILABLE;</div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> occupied                                    OBJC2_UNAVAILABLE;</div><div class="line">    Method buckets[<span class="number">1</span>]                                        OBJC2_UNAVAILABLE;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">struct</span> objc_protocol_list &#123;</div><div class="line">    <span class="keyword">struct</span> objc_protocol_list *next;</div><div class="line">    <span class="keyword">long</span> count;</div><div class="line">    Protocol *<span class="built_in">list</span>[<span class="number">1</span>];</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">struct</span> objc_ivar &#123;</div><div class="line">    <span class="keyword">char</span> *ivar_name                                          OBJC2_UNAVAILABLE;</div><div class="line">    <span class="keyword">char</span> *ivar_type                                          OBJC2_UNAVAILABLE;</div><div class="line">    <span class="keyword">int</span> ivar_offset                                          OBJC2_UNAVAILABLE;</div><div class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __LP64__</span></div><div class="line">    <span class="keyword">int</span> space                                                OBJC2_UNAVAILABLE;</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line">&#125;  </div><div class="line"></div><div class="line"><span class="keyword">struct</span> objc_method &#123;</div><div class="line">    SEL method_name                                          OBJC2_UNAVAILABLE;</div><div class="line">    <span class="keyword">char</span> *method_types                                       OBJC2_UNAVAILABLE;</div><div class="line">    IMP method_imp                                           OBJC2_UNAVAILABLE;</div><div class="line">&#125;                                                            OBJC2_UNAVAILABLE;</div></pre></td></tr></table></figure>
<p>上面这段 <code>C</code> 语言代码应该不是特别难理解。我们事实上可以直接理解为 <code>objc_ivar_list</code> 结构体存储着 <code>objc_ivar</code> 数组列表，而 <code>objc_ivar</code> 结构体存储了类的单个成员变量的信息；同理 <code>objc_method_list</code> 结构体存储着 <code>objc_method</code> 数组列表，而 <code>objc_method</code> 结构体存储了类的某个方法的信息；<code>objc_protocol_list</code> 结构体存储着类的遵循的协议的信息。</p>
<p>这里还有一个 <code>objc_cache</code>，顾名思义它是缓存，它在 <code>objc_class</code> 的作用很重要。我们在 <code>runtime.h</code> 文件中找到了 <code>Cache</code> 的定义：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> objc_cache *Cache                             OBJC2_UNAVAILABLE;</div><div class="line"></div><div class="line"><span class="keyword">struct</span> objc_cache &#123;</div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> mask <span class="comment">/* total = mask + 1 */</span>                 OBJC2_UNAVAILABLE;</div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> occupied                                    OBJC2_UNAVAILABLE;</div><div class="line">    Method buckets[<span class="number">1</span>]                                        OBJC2_UNAVAILABLE;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> old_method *Method;</div><div class="line"></div><div class="line"><span class="keyword">struct</span> old_method &#123;</div><div class="line">    SEL method_name;</div><div class="line">    <span class="keyword">char</span> *method_types;</div><div class="line">    IMP method_imp;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<blockquote>
<p><code>Cache</code> 为方法调用的性能进行优化，通俗地讲，每当实例对象接收到一个消息时，它不会直接在 <code>isa</code> 指向的类的方法列表中遍历查找能够响应消息的方法，因为这样效率太低了，而是优先在 <code>Cache</code> 中查找。<code>Runtime</code> 系统会把被调用的方法存到 <code>Cache</code> 中（理论上讲一个方法如果被调用，那么它有可能今后还会被调用），下次查找的时候效率更高。这跟计算机组成原理中学过的 <code>CPU</code> 绕过主存先访问 <code>Cache</code> 的道理挺像，而我猜苹果为提高 <code>Cache</code> 命中率应该也做了努力吧。</p>
</blockquote>
<p>根据源码可以看到 <code>objc_cache</code> 中存储了两个 <code>unsigned int</code> 类型的变量和一个 <code>Method</code> 类型的变量。</p>
<p><code>mask</code>：分配用来缓存 <code>bucket</code> 的总数。</p>
<p><code>occupied</code>：表明目前实际占用的缓存 <code>bucket</code> 的个数。</p>
<p><code>Method</code> 结构体中存储了一个 <code>SEL</code> 类型的方法名，方法类型和一个 <code>IMP</code> 类型的方法指针。</p>
<p><code>Method buckets[1]</code> 其实就是一个散列表，用来存储 <code>Method</code> 的链表。</p>
<p><code>IMP</code> 实际上就是指向一个方法实现的指针。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/// A pointer to the function of a method implementation. </span></div><div class="line"><span class="meta">#<span class="meta-keyword">if</span> !OBJC_OLD_DISPATCH_PROTOTYPES</span></div><div class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*IMP)</span><span class="params">(<span class="keyword">void</span> <span class="comment">/* id, SEL, ... */</span> )</span></span>; </div><div class="line"><span class="meta">#<span class="meta-keyword">else</span></span></div><div class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">id</span> <span class="params">(*IMP)</span><span class="params">(id, SEL, ...)</span></span>; </div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div></pre></td></tr></table></figure>
<p>了解完了 <code>NSObject</code> 的具体实现，我们来看下一个实例到底是如何来实现消息传递的。</p>
<p>首先我们举一个例子，我们定义这样一个类：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>: <span class="title">NSObject</span> </span>&#123;</div><div class="line">    </div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Man</span>: <span class="title">Person</span> </span>&#123;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>然后实例化一个对象：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> ramsey = <span class="type">Man</span>()</div></pre></td></tr></table></figure>
<p>我们在 <code>objc.h</code> 中找到一个类的实例的结构如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/// Represents an instance of a class.</span></div><div class="line"><span class="keyword">struct</span> objc_object &#123;</div><div class="line">    Class isa  OBJC_ISA_AVAILABILITY;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>类的实例对象中有一个 <code>isa</code> 指针，这个指针是指向它的类。</p>
<p>由于 <code>Man</code> 继承自 <code>Person</code>, <code>Person</code> 继承自 <code>NSObject</code> 类，所以它也继承了 <code>NSObject</code> 的 <code>isa</code>, 所以实例对象 <code>ramsey</code> 的这个 <code>isa</code> 指针实际上就是指向他的类 <code>Man</code>，由于这个类 <code>Man</code> 是一个 <code>Class</code> 类型的结构体，所以它还包含一个叫 <code>super_class</code> 的指向 <code>Class</code>(也就是 <code>objc_class</code> 结构体类型) 类型的指针，在这里， <code>super_class</code> 指向它的父类 <code>Man</code>，而 <code>Man</code> 类结构体中的叫 <code>isa</code> 的指向 <code>Class</code> 类型的指针指向的是他的元类，而元类结构体里的结构也是一样的， <code>super_class</code> 指针指向元类的父类也就是 <code>Man</code> 类的元类， <code>isa</code> 指针则指向根类 <code>NSObject</code> 的元类。至此，这一层的指针都有了指向，然后再去父类中，按照相同的逻辑一直到根类 <code>NSObject</code> 中，<code>NSObject</code> 没有父类，它的父类指向 <code>nil</code>，而他的元类的 <code>super_class</code> 则直接指向 <code>NSObject</code>，元类的 <code>isa</code> 也指向 <code>NSObject</code>。用一张图表示，则如下图：</p>
<p><img src="https://raw.githubusercontent.com/seamusapple/MarkDownPics/master/iOS-Runtime/class-diagram.jpg" alt=""></p>
<p>注意点：</p>
<ul>
<li><p>Root class (class)其实就是 <code>NSObject</code>，<code>NSObject</code>是没有超类的，所以Root class(class)的 <code>superclass</code> 指向 <code>nil</code>。</p>
</li>
<li><p>每个Class都有一个 <code>isa</code> 指针指向唯一的Meta class</p>
</li>
<li><p>Root class(meta)的 <code>superclass</code> 指向Root class(class)，也就是 <code>NSObject</code>，形成一个回路。</p>
</li>
<li><p>每个Meta class的 <code>isa</code> 指针都指向Root class (meta)。</p>
</li>
</ul>
<p>那这个元类存在的意义到底是什么呢？</p>
<p>是因为类方法而存在。</p>
<p><strong>对象的实例方法调用时，通过对象的 <code>isa</code> 在类中获取方法的实现。</strong></p>
<p><strong>类对象的类方法调用时，通过类的 <code>isa</code> 在元类中获取方法的实现。</strong></p>
<p>meta-class之所以重要，是因为它存储着一个类的所有类方法。每个类都会有一个单独的meta-class，因为每个类的类方法基本不可能完全相同。</p>
<p>想要深入理解元类，可以查看<a href="http://www.cocoawithlove.com/2010/01/what-is-meta-class-in-objective-c.html" target="_blank" rel="external">这篇文章</a></p>
<h3 id="Runtime-术语"><a href="#Runtime-术语" class="headerlink" title="Runtime 术语"></a><code>Runtime</code> 术语</h3><p>我们已经知道了 <code>NSObject</code> 的结构了，在开始学习 <code>Runtime</code> 的消息机制之前，一些准备工作还是需要的，了解下一些专业术语有助于我们更好的学习 <code>Runtime</code>。</p>
<h4 id="SEL"><a href="#SEL" class="headerlink" title="SEL"></a><code>SEL</code></h4><p>在 <code>objc.h</code> 头文件中找到 <code>SEL</code> 的定义：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/// An opaque type that represents a method selector.</span></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> objc_selector *SEL;</div></pre></td></tr></table></figure>
<p><code>SEL</code> 是 <code>selector</code> ( <code>Swift</code> 中 <code>Selector</code>) 在 <code>Objective-C</code> 中的表示形式，<code>selector</code> 是方法选择器，而 <code>SEL</code> 是一个指向 <code>objc_selector</code> 的指针，可以理解为 <code>SEL</code> 是一个方法的编号（类似于 <code>C</code> 语言中的函数地址），<code>selector</code> 是通过方法编号（这个编号就是 <code>SEL</code> 类型的）来去方法的方法选择器，通过 <code>@selector</code> 则是去寻找方法地址，也就是去找匹配这个 <code>SEL</code> 类型的编号，找到方法地址（编号）之后就可以取出相应的方法。</p>
<h4 id="id"><a href="#id" class="headerlink" title="id"></a><code>id</code></h4><p>在 <code>objc.h</code> 头文件中找到 <code>id</code> 的定义：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/// A pointer to an instance of a class.</span></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> objc_object *id;</div><div class="line"></div><div class="line"><span class="comment">/// Represents an instance of a class.</span></div><div class="line"><span class="keyword">struct</span> objc_object &#123;</div><div class="line">    Class isa  OBJC_ISA_AVAILABILITY;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p><code>id</code> 是一个指向实例类对象的指针，<code>objc_object</code> 结构体包含一个 <code>isa</code> 指针，根据 <code>isa</code> 指针就可以顺藤摸瓜找到对象所属的类。</p>
<blockquote>
<p><code>isa</code> 指针不总是指向实例对象所属的类，不能依靠它来确定类型，而是应该用 <code>class</code> 方法来确定实例对象的类。因为 <code>KVO</code> 的实现机理就是将被观察对象的 <code>isa</code> 指针指向一个中间类而不是真实的类，这是一种叫做 <code>isa-swizzling</code> 的技术，详见<a href="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/KeyValueObserving/Articles/KVOImplementation.html" target="_blank" rel="external">官方文档</a>。</p>
</blockquote>
<h4 id="Method"><a href="#Method" class="headerlink" title="Method"></a><code>Method</code></h4><p>在 <code>runtime.h</code> 头文件中找到 <code>Method</code> 的定义：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/// An opaque type that represents a method in a class definition.</span></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> objc_method *Method;</div><div class="line"></div><div class="line"><span class="keyword">struct</span> objc_method &#123;</div><div class="line">    SEL method_name                                          OBJC2_UNAVAILABLE;</div><div class="line">    <span class="keyword">char</span> *method_types                                       OBJC2_UNAVAILABLE;</div><div class="line">    IMP method_imp                                           OBJC2_UNAVAILABLE;</div><div class="line">&#125;                                                            OBJC2_UNAVAILABLE;</div></pre></td></tr></table></figure>
<p><code>Method</code> 是一个指向结构体的指针，这个结构体里存储着方法名字，方法类型以及方法实现。所以 <code>Method</code> 类型其实就是代表类中某个方法的类型。</p>
<ul>
<li><p>方法名 <code>method_name</code> 是 <code>SEL</code> 类型，值得注意的是相同名字的方法及时在不同的类中，他们的方法选择器也相同。</p>
</li>
<li><p>方法类型 <code>method_types</code> 是个 <code>char</code> 指针，指针所指向的地址存放着方法参数类型以及返回值类型。</p>
</li>
<li><p><code>method_imp</code> 指向了某个方法的具体实现，他是 <code>IMP</code> 类型的，实际上是个指针。</p>
</li>
</ul>
<h4 id="IMP"><a href="#IMP" class="headerlink" title="IMP"></a><code>IMP</code></h4><p>在 <code>objc.h</code> 头文件中找到 <code>IMP</code> 的定义：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/// A pointer to the function of a method implementation. </span></div><div class="line"><span class="meta">#<span class="meta-keyword">if</span> !OBJC_OLD_DISPATCH_PROTOTYPES</span></div><div class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*IMP)</span><span class="params">(<span class="keyword">void</span> <span class="comment">/* id, SEL, ... */</span> )</span></span>; </div><div class="line"><span class="meta">#<span class="meta-keyword">else</span></span></div><div class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">id</span> <span class="params">(*IMP)</span><span class="params">(id, SEL, ...)</span></span>; </div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div></pre></td></tr></table></figure>
<p><code>IMP</code> 是 implementation 的缩写，它是一个指向方法实现的指针。</p>
<p>这里补充一个 <code>C</code> 语言的小知识，函数指针。</p>
<blockquote>
<p>函数指针是指向函数的指针，包含了函数的地址，可以通过它来调用函数。声明格式如下:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">类型说明符 (*函数名)(参数)。</div></pre></td></tr></table></figure>
<p>其实这里不能称为函数名，应该叫做指针的变量名。这个特殊的指针指向一个返回特定类型的函数。指针的声明必须和它指向函数的声明保持一致。</p>
 <figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">char</span> (*pFun)(<span class="keyword">int</span>);</div></pre></td></tr></table></figure>
<p>例如上面这句话代表的意思是定义了一个指针变量 <code>pFun</code>，他是一个指向某个函数的指针，这个函数有一个 <code>int</code> 型的参数，返回值是 <code>char</code>    类型。</p>
<p>我们可以使用 <code>typedef</code> 来似的函数指针的定义更直观。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span>  返回类型(*新类型)(参数表)</div></pre></td></tr></table></figure>
<p> <code>typedef</code> 的功能是定义新的类型。这句话就是定义了一种 <code>PTRFUN</code> 的类型，并定义这种类型为指向某种函数的指针，这种函数以一个 <code>int</code> 为参数并返回 <code>char</code> 类型。后面就可以像使用 <code>int</code>, <code>char</code> 一样使用 <code>PTRFUN</code> 了。</p>
</blockquote>
<p>所以现在我们知道了 <code>IMP</code> 是一个新类型，这种类型是一个指向某种函数的指针，这种函数的参数是 <code>id</code> 和 <code>SEL</code>, 返回值是 <code>id</code>。 </p>
<p>那么 <code>IMP</code> 有什么作用呢？有了 <code>IMP</code>，理论上我们就可以直接绕开消息传递的阶段，直接执行方法。</p>
<p><code>IMP</code> 指向的函数有两个参数，<code>id</code> 代表某个具体的实例对象，每个方法都对应一个 <code>SEL</code> 类型的方法选择器，而每个实例对象中的 <code>SEL</code> 对应的方法实现肯定是唯一的，如此，通过 <code>id</code> 和 <code>SEL</code> 两个参数就可以确认唯一的方法实现地址。</p>
<p>这里我们可以举个例子还看下 <code>IMP</code> 的具体使用，我们通过重写之前文章的 <code>Method Swizzling</code> 的例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line">#import &quot;UIViewController+ViewDidLoad.h&quot;</div><div class="line">#import &lt;objc/objc-class.h&gt;</div><div class="line"></div><div class="line">/*</div><div class="line"> 这里之所以自定义了IMP，主要是因为环境配置的原因。</div><div class="line"> Xcode默认情况下这么个配置</div><div class="line"> Enable Strict Checking of objc_msgSend Calls</div><div class="line"> 设置为 YES</div><div class="line"> 这种情况下IMP被定义为无参数无返回值的函数。</div><div class="line"> 所以你需要到工程里搜索到这个选项并把它关闭。</div><div class="line"> 这样的麻烦就是，每次使用，你都需要修改工程配置。</div><div class="line"> 这里我们就重新定义一个和有参数的IMP指针相同的指针类型，在获取有参数的IMP时把它强转为此类型。</div><div class="line"> 再重新定义一个和无参数的IMP指针相同的指针类型，在获取无参数的IMP时把它强转为此类型。</div><div class="line"> */</div><div class="line">typedef id (*_IMP)(id, SEL, ...);</div><div class="line">typedef void (*_VIMP)(id, SEL, ...);</div><div class="line"></div><div class="line">@implementation UIViewController (ViewDidLoad)</div><div class="line"></div><div class="line">+ (void)load &#123;</div><div class="line">    // 保证方法只执行一次</div><div class="line">    static dispatch_once_t onceToken;</div><div class="line">    dispatch_once(&amp;onceToken, ^&#123;</div><div class="line">        // 获取原始方法</div><div class="line">        Method viewDidLoad = class_getInstanceMethod(self, @selector(viewDidLoad));</div><div class="line">        // 获取原始方法的实现</div><div class="line">        _IMP viewDidLoad_IMP = (_IMP)method_getImplementation(viewDidLoad);</div><div class="line">        // 重新设置方法实现</div><div class="line">        method_setImplementation(viewDidLoad, imp_implementationWithBlock(^(id target, SEL action) &#123;</div><div class="line">            // 调用原有方法实现</div><div class="line">            viewDidLoad_IMP(target, @selector(viewDidLoad));</div><div class="line">            // 新增代码</div><div class="line">            NSLog(@&quot;%@ did load&quot;, target);</div><div class="line">        &#125;));</div><div class="line">    &#125;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">@end</div><div class="line"></div><div class="line">// &lt;ViewController: 0x7fca7ce05f30&gt; did load</div></pre></td></tr></table></figure>
<p>值得注意的是，如果你重写的方法有返回值，不要忘记在最后做 <code>return</code>。</p>
<p>实际上直接调用一个方法的 <code>IMP</code> 指针的效率是高于调用方法本身的，所以，如果有一个合适的时机获取到方法的 <code>IMP</code> 的话，可以尝试使用一下。</p>
<h4 id="Ivar"><a href="#Ivar" class="headerlink" title="Ivar"></a><code>Ivar</code></h4><p>在 <code>runtime.h</code> 头文件中找到 <code>Ivar</code> 的定义：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/// An opaque type that represents an instance variable.</span></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> objc_ivar *Ivar;</div></pre></td></tr></table></figure>
<p><code>Ivar</code> 是一种代表类中实例变量的类型。</p>
<p>而 <code>objc_ivar</code>在上面的成员变量列表中也提到过：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> objc_ivar &#123;</div><div class="line">    <span class="keyword">char</span> *ivar_name                                          OBJC2_UNAVAILABLE;</div><div class="line">    <span class="keyword">char</span> *ivar_type                                          OBJC2_UNAVAILABLE;</div><div class="line">    <span class="keyword">int</span> ivar_offset                                          OBJC2_UNAVAILABLE;</div><div class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __LP64__</span></div><div class="line">    <span class="keyword">int</span> space                                                OBJC2_UNAVAILABLE;</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以根据实例查找其在类中的名字，也就是“反射”：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">-(NSString *)nameWithInstance:(id)instance &#123;</div><div class="line">    unsigned int numIvars = 0;</div><div class="line">    NSString *key = nil;</div><div class="line">    Ivar * ivars = class_copyIvarList([self class], &amp;numIvars);</div><div class="line">    for(int i = 0; i &lt; numIvars; i++) &#123;</div><div class="line">        Ivar thisIvar = ivars[i];</div><div class="line">        const char *type = ivar_getTypeEncoding(thisIvar);</div><div class="line">        NSString *stringType =  [NSString stringWithCString:type encoding:NSUTF8StringEncoding];</div><div class="line">        if (![stringType hasPrefix:@&quot;@&quot;]) &#123;</div><div class="line">            continue;</div><div class="line">        &#125;</div><div class="line">        if ((object_getIvar(self, thisIvar) == instance)) &#123;//此处若 crash 不要慌！</div><div class="line">            key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];</div><div class="line">            break;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    free(ivars);</div><div class="line">    return key;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>class_copyIvarList</code> 函数获取的不仅有实例变量，还有属性。但会在原本的属性名前加上一个下划线。</p>
<h4 id="Property"><a href="#Property" class="headerlink" title="Property"></a><code>Property</code></h4><p><code>@property</code> 标记了类中的属性，这个不必多说大家都很熟悉，它是一个指向 <code>objc_property</code> 结构体的指针：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> objc_property *Property;</div><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> objc_property *<span class="keyword">objc_property_t</span>;<span class="comment">//这个更常用</span></div></pre></td></tr></table></figure>
<p>可以通过 <code>class_copyPropertyList</code> 和 <code>protocol_copyPropertyList</code> 方法来获取类和协议中的属性：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">objc_property_t *class_copyPropertyList(Class cls, unsigned int *outCount)</div><div class="line">objc_property_t *protocol_copyPropertyList(Protocol *proto, unsigned int *outCount)</div></pre></td></tr></table></figure>
<p>返回类型为指向指针的指针，因为属性列表是个数组，每个元素内容都是一个 <code>objc_property_t</code> 指针，而这两个函数返回的值是指向这个数组的指针。</p>
<p>举个栗子，先声明一个类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">@interface Lender : NSObject &#123;</div><div class="line">    float alone;</div><div class="line">&#125;</div><div class="line">@property float alone;</div><div class="line">@end</div></pre></td></tr></table></figure>
<p>然后可以通过下面的方法获取它的属性</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">// 获取属性列表</div><div class="line">id LenderClass = objc_getClass(&quot;Lender&quot;);</div><div class="line">unsigned int outCount, i;</div><div class="line">objc_property_t *properties = class_copyPropertyList(LenderClass, &amp;outCount);</div><div class="line">for (i = 0; i &lt; outCount; i++) &#123;</div><div class="line">    objc_property_t property = properties[i];</div><div class="line">    // class_getProperty 和 protocol_getProperty 这两个方法来在类和协议中获取属性的引用</div><div class="line">    // property_getName 函数来查找属性名称</div><div class="line">    // property_getAttributes 函数来发掘属性的名称和@encode类型字符串</div><div class="line">    fprintf(stdout, &quot;%s %s\n&quot;, property_getName(property), property_getAttributes(property));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>对比下 <code>class_copyIvarList</code> 函数，使用 <code>class_copyPropertyList</code> 函数只能获取类的属性，而不包含成员变量。但此时获取的属性名是不带下划线的。</p>
<p>了解完了 <code>Runtime</code> 的一些专业术语之后，我们来看看它的消息机制到底是什么？</p>
<h2 id="Runtime-的消息"><a href="#Runtime-的消息" class="headerlink" title="Runtime 的消息"></a><code>Runtime</code> 的消息</h2><h3 id="objc-msgSend-方法"><a href="#objc-msgSend-方法" class="headerlink" title="objc_msgSend 方法"></a><code>objc_msgSend</code> 方法</h3><p>在 <code>Obejctive-C</code> 中消息直到运行时才会与方法实现进行绑定。我们平时写代码的时候会写如下代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[receiver message]</div></pre></td></tr></table></figure>
<p>编译器会将这样一条消息转换为</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">objc_msgSend(receiver, selector)</div></pre></td></tr></table></figure>
<p>如果发送的消息有参数，那么这些参数也会同时传给 <code>objc_msgSend</code> 方法：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">objc_msgSend(receiver, selector, arg1, arg2, ...)</div></pre></td></tr></table></figure>
<p><code>objc_msgSend</code> 的源码是用汇编语言实现的，和它类似的方法还有如下几个：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">objc_msgSend_stret（返回值是结构体）  </div><div class="line">objc_msgSend_fpret（返回值是浮点型）  </div><div class="line">objc_msgSendSuper（调用父类方法）  </div><div class="line">objc_msgSendSuper_stret（调用父类方法，返回值是结构体）</div></pre></td></tr></table></figure>
<p>它们的作用都是类似的，为了简单起见，后续介绍消息和消息传递机制都以 <code>objc_msgSend</code> 方法为例。</p>
<p>我们找到 <code>message.h</code> 头文件中 <code>objc_msgSend</code> 的声明：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function">OBJC_EXPORT id <span class="title">objc_msgSend</span><span class="params">(id self, SEL op, ...)</span></span></div><div class="line"><span class="comment">/*</span></div><div class="line">self: 指向实例的类的指针，这个类会接收消息。</div><div class="line">op: 处理消息的方法的方法选择器</div><div class="line">id: 这个方法的返回值。注意 objc_msgSend 本身是没有返回值的，这个返回值是发送消息的方法的返回值。</div><div class="line">*/</div></pre></td></tr></table></figure>
<p>为了能够动态绑定，消息方法会经过下面三个过程：</p>
<ul>
<li><p>首先它会去找到方法选择器所指的方法的实现。由于不同的类可以允许相同名字的方法实现的存在，因此它会根据接收者的类来确定具体的方法实现。</p>
</li>
<li><p>然后它会将接收者对象(实际上就是 <code>self</code> 这个指针)、所需要的参数传递给程序。</p>
</li>
<li><p>最后它会讲程序(实际上的方法)的返回值作为自己的返回值传回来。这也就是 <code>objc_msgSend</code> 方法其实没有返回值，它的返回值 <code>id</code> 是实际上的方法的返回值。</p>
</li>
</ul>
<p>消息传递的关键点在于编译器为每个类或者对象构建的结构，每个类结构都包含下面两个必要的元素：</p>
<ul>
<li><p>一个指向父类的指针。</p>
</li>
<li><p>一个类的分发表(dispatch table)。这个分发表其实就是方法列表，他将类中的方法选择器和方法实现地址关联了起来。</p>
</li>
</ul>
<p>当一个对象呗实例化的时候，首先会开辟一段内存给它，然后它的实例变量会被初始化。回想上面提到的，对象的结构：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/// Represents an instance of a class.</span></div><div class="line"><span class="keyword">struct</span> objc_object &#123;</div><div class="line">    Class isa  OBJC_ISA_AVAILABILITY;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>在对象的变量中一定有一个指向它所属类的指针 <code>isa</code>，这样对象就可以和它的类联系到一起了，然后通过类中的 <code>super_class</code> 指针就可以和它的父类联系起来了。</p>
<p>下面这张图描述了这种关系。</p>
<p><img src="https://raw.githubusercontent.com/seamusapple/MarkDownPics/master/iOS-Runtime/messaging1.gif" alt=""></p>
<p>还记得我们之前学习 <code>NSObject</code> 的结构体的时候里面有个 <code>cache</code>,这个 <code>cache</code> 就是在这消息发送的过程中被利用的，用来优化寻找方法实现的逻辑。运行时系统会自动缓存一些用过的方法实现和方法选择器(当然是一一对应起来的，理论上一个方法被使用过后，那么它还被使用的概率很高)，每个类都有自己的方法缓存，缓存里不仅可以保存定义在自己类中的方法选择器和方法实现，还可以保存继承来的方法实现和方法选择器。缓存里的方法选择器理论上会越来越多，并且随着程序一直在被运行，几乎所有的方法选择器都可以在缓存中找到，这大大提高了效率。</p>
<p>通过上面这些知识，我们就可以知道一个消息被发送给一个对象之后，它所代表的方法实现到底是如何被找到并且执行的：</p>
<ul>
<li><p>检测这个 <code>selector</code> 是不是要忽略的。比如 <code>Mac OS X</code> 开发，有了垃圾回收就不理会 <code>retain</code>, <code>release</code> 这些函数了。</p>
</li>
<li><p>检测这个 <code>target</code> 是不是 <code>nil</code> 对象。<code>Objective-C</code> 的特性是允许对一个 <code>nil</code> 对象执行任何一个方法不会 <code>Crash</code>，因为会被忽略掉。</p>
</li>
<li><p>如果上面两个都过了，那就开始查找这个类的 <code>IMP</code>，先从 <code>cache</code> 里面找，完了找得到就跳到对应的函数去执行。</p>
</li>
<li><p>如果 <code>cache</code> 找不到就找一下方法分发表。</p>
</li>
<li><p>如果分发表找不到就到父类的分发表去找，一直找，直到找到 <code>NSObject</code> 类为止。找到了就将方法加入对应类的 <code>cache</code> 表中。</p>
</li>
<li><p>如果还找不到就要开始进入动态方法解析了。后面会提到。</p>
</li>
<li><p>如果动态方法解析仍不能解决问题，只能进行最后一次尝试，进入消息转发流程。后面会提到。</p>
</li>
<li><p>如果还没找到，那我也没辙了。</p>
</li>
</ul>
<h3 id="使用隐藏参数"><a href="#使用隐藏参数" class="headerlink" title="使用隐藏参数"></a>使用隐藏参数</h3><p>当 <code>objc_msgSend</code> 方法找到消息所对应的方法实现后，会将所有的方法参数传递给方法实现，同时也会传递两个隐藏参数，就像上面我们看到 <code>objc_msgSend</code> 的结构里一样：</p>
<ul>
<li><p>一个参数代表接收对象(<code>self</code>)</p>
</li>
<li><p>一个参数代表这个方法的方法选择器(<code>_cmd</code>)</p>
</li>
</ul>
<p>之所以这个两个参数被称为隐藏参数，是因为它们并没有被定义在源码里，而是代码被编译的时候被插入到方法实现中，尽管如此，在源码我们仍然可以引用它们，我们仍然可以使用这两个隐藏参数，<code>self</code> 引用了接收者对象，而 <code>_cmd</code> 引用了方法本身的选择器：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">- strange</div><div class="line">&#123;</div><div class="line">    id  target = getTheReceiver();</div><div class="line">    SEL method = getTheMethod();</div><div class="line"> </div><div class="line">    if ( target == self || method == _cmd )</div><div class="line">        return nil;</div><div class="line">    return [target performSelector:method];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这两个参数中， <code>self</code> 明显更有用，它是方法实现中访问消息对象的实例变量的途径。</p>
<p>那我们顺便来看看下面这个方法：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="function">OBJC_EXPORT id <span class="title">objc_msgSendSuper</span><span class="params">(<span class="keyword">struct</span> objc_super *super, SEL op, ...)</span></span></div><div class="line"></div><div class="line"><span class="comment">/// Specifies the superclass of an instance. </span></div><div class="line"><span class="keyword">struct</span> objc_super &#123;</div><div class="line">    <span class="comment">/// Specifies an instance of a class.</span></div><div class="line">    __unsafe_unretained id receiver;</div><div class="line"></div><div class="line">    <span class="comment">/// Specifies the particular superclass of the instance to message. </span></div><div class="line"><span class="meta">#<span class="meta-keyword">if</span> !defined(__cplusplus)  &amp;&amp;  !__OBJC2__</span></div><div class="line">    <span class="comment">/* For compatibility with old objc-runtime.h header */</span></div><div class="line">    __unsafe_unretained Class <span class="keyword">class</span>;</div><div class="line"><span class="meta">#<span class="meta-keyword">else</span></span></div><div class="line">    __unsafe_unretained Class super_class;</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line">    <span class="comment">/* super_class is the first class to search */</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>我们结合源码以及里面的解释，可以看到，当方法中的 <code>super</code> 关键字接收消息的时候，会调用 <code>objc_msgSendSuper</code> 方法，而此时编译器会创建一个 <code>objc_super</code> 结构体，这个结构体里指明了消息的接收者以及消息被传递的对象。通俗的讲就是，当使用 <code>super</code> 关键字的时候，消息的接收者永远都是 <code>self</code>，而消息的实现会在父类中查找。</p>
<h4 id="练习-一-self-class-与-super-class"><a href="#练习-一-self-class-与-super-class" class="headerlink" title="练习(一) [self class] 与 [super class]"></a>练习(一) <code>[self class]</code> 与 <code>[super class]</code></h4><p>那么看下下面这个例子：</p>
<blockquote>
<p>下面这段代码会输出什么？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">@implementation Son : Father</div><div class="line">- (id)init</div><div class="line">&#123;</div><div class="line">    self = [super init];</div><div class="line">    if (self)</div><div class="line">    &#123;</div><div class="line">        NSLog(@&quot;%@&quot;, NSStringFromClass([self class]));</div><div class="line">        NSLog(@&quot;%@&quot;, NSStringFromClass([super class]));</div><div class="line">    &#125;</div><div class="line">return self;</div><div class="line">&#125;</div><div class="line">@end</div></pre></td></tr></table></figure>
</blockquote>
<p>我们来分析下，当执行到 <code>[self class]</code> 这句话的时候，运行时系统会调用 <code>obj_msgSend</code> 方法，接收者是 <code>self</code>，也就是本类，所以会在 <code>Son</code> 这个类中查找 <code>class</code> 方法的 <code>IMP</code>，显然是找不到的，因为 <code>class</code> 这个方法是在 <code>NSObject</code> 类中定义的，所以会一直找到 <code>NSObject</code> 类中，最终在 <code>NSObject</code> 类中找到 <code>class</code> 方法的 <code>IMP</code>，找到后调用 <code>object_getClass()</code>, 最后变成 <code>obj_msgSend(self, @selector(class))</code>, 其结果是 <code>Son</code>。</p>
<p>当执行 <code>[super class]</code> 这句话的时候，会调用 <code>obj_msgSendSuper</code> 方法，然后找到父类 <code>super_class</code>，开始查找 <code>class</code> 的 <code>selector</code>，找不到，再去 <code>NSObject</code> 中找，最终找到了，然后调用者调用这个方法实现，<code>objc_msgSendSuper</code> 变成了 <code>objc_msgSend(objc_super-&gt;receiver, @selector(class))</code>，调用者依旧是 <code>self</code>，所以返回值仍然是 <code>Son</code>。</p>
<h4 id="练习-二-isKindOfClass-与-isMemberOfClass"><a href="#练习-二-isKindOfClass-与-isMemberOfClass" class="headerlink" title="练习(二) isKindOfClass 与 isMemberOfClass"></a>练习(二) <code>isKindOfClass</code> 与 <code>isMemberOfClass</code></h4><blockquote>
<p>下面代码输出什么？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">@interface Sark : NSObject</div><div class="line">@end</div><div class="line">&gt;</div><div class="line">@implementation Sark</div><div class="line">@end</div><div class="line">&gt;</div><div class="line">int main(int argc, const char * argv[]) &#123;</div><div class="line">@autoreleasepool &#123;</div><div class="line">    BOOL res1 = [(id)[NSObject class] isKindOfClass:[NSObject class]];</div><div class="line">    BOOL res2 = [(id)[NSObject class] isMemberOfClass:[NSObject class]];</div><div class="line">    BOOL res3 = [(id)[Sark class] isKindOfClass:[Sark class]];</div><div class="line">    BOOL res4 = [(id)[Sark class] isMemberOfClass:[Sark class]];</div><div class="line">&gt;</div><div class="line">   NSLog(@&quot;%d %d %d %d&quot;, res1, res2, res3, res4);</div><div class="line">&#125;</div><div class="line">return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</blockquote>
<p>我们首先在找到这几个方法的源码实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div></pre></td><td class="code"><pre><div class="line">+ (Class)class &#123;</div><div class="line">    return self;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (Class)class &#123;</div><div class="line">    return object_getClass(self);</div><div class="line">&#125;</div><div class="line"></div><div class="line">Class object_getClass(id obj)</div><div class="line">&#123;</div><div class="line">    if (obj) return obj-&gt;getIsa();</div><div class="line">    else return Nil;</div><div class="line">&#125;</div><div class="line"></div><div class="line">/*</div><div class="line">inline关键字</div><div class="line">意义：表示内联函数</div><div class="line">作用：为了解决函数调用效率问题</div><div class="line">原理：编译的时候会把代码直接嵌入刀调用代码中，省去了汇编时候的call指令。</div><div class="line">	  call指令作用如下：</div><div class="line">	  1. 将下一条指令的所在地址（即当时程序计数器PC的内容）入栈</div><div class="line">	  2. 并将子程序的起始地址送入PC（于是CPU的下一条指令就会转去执行子程序）。</div><div class="line">优点：与#define宏定义类似，相当于用#define宏定义定义了一个函数。</div><div class="line">*/</div><div class="line"></div><div class="line">/*</div><div class="line">::作用域运算符</div><div class="line">意义：作用域运算符描述成员所属的类。</div><div class="line">格式：&lt;类&gt;::&lt;成员名&gt;。</div><div class="line">解读：在这里表示getIsa() 方法定义在 objc_object 中，但并未实现，在这里实现了。</div><div class="line">*/</div><div class="line"></div><div class="line">/* </div><div class="line">tagged pointer：对64位的设备对象进行类对象指针的优化，利用合理的bit（arm64设备为32位）存储类对象的地址，其他位用来进行内存管理。这种优化模式被称为tagged pointer。</div><div class="line">*/</div><div class="line">// 支持tagged pointer时候获取Class的函数</div><div class="line">inline Class </div><div class="line">objc_object::getIsa() </div><div class="line">&#123;</div><div class="line">#if SUPPORT_TAGGED_POINTERS</div><div class="line">    if (isTaggedPointer()) &#123;</div><div class="line">        uintptr_t slot = ((uintptr_t)this &gt;&gt; TAG_SLOT_SHIFT) &amp; TAG_SLOT_MASK;</div><div class="line">        return objc_tag_classes[slot];</div><div class="line">    &#125;</div><div class="line">#endif</div><div class="line">    return ISA();</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 不支持tagged pointer时候获取Class的函数</div><div class="line">inline Class </div><div class="line">objc_object::ISA() </div><div class="line">&#123;</div><div class="line">    assert(!isTaggedPointer()); </div><div class="line">    return isa.cls;</div><div class="line">&#125;</div><div class="line"></div><div class="line">+ (BOOL)isMemberOfClass:(Class)cls &#123;</div><div class="line">    return object_getClass((id)self) == cls;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (BOOL)isMemberOfClass:(Class)cls &#123;</div><div class="line">    return [self class] == cls;</div><div class="line">&#125;</div><div class="line"></div><div class="line">+ (BOOL)isKindOfClass:(Class)cls &#123;</div><div class="line">    for (Class tcls = object_getClass((id)self); tcls; tcls = tcls-&gt;superclass) &#123;</div><div class="line">        if (tcls == cls) return YES;</div><div class="line">    &#125;</div><div class="line">    return NO;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (BOOL)isKindOfClass:(Class)cls &#123;</div><div class="line">    for (Class tcls = [self class]; tcls; tcls = tcls-&gt;superclass) &#123;</div><div class="line">        if (tcls == cls) return YES;</div><div class="line">    &#125;</div><div class="line">    return NO;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>先来分析第一句话：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">BOOL res1 = [(id)[NSObject class] isKindOfClass:[NSObject class]];</div></pre></td></tr></table></figure>
<p>首先执行 <code>[NSObject class]</code>，这个返回的就是 <code>NSObject</code> 本身，很好理解。</p>
<p>接着看下 <code>+ (BOOL)isKindOfClass:(Class)cls</code> 这个方法。这个方法内部，会先去通过 <code>object_getClass</code> 这个方法去获取 <code>self</code> 本身的类，也就是接收者本身的类，而 <code>object_getClass</code> 的源码实现是去调用当前类的 <code>obj-&gt;getIsa()</code>，最后在 <code>ISA()</code> 方法中获得 <code>meta class</code> 的指针（记得类的结构体中的 <code>isa</code> 指针是指向他的元类）。接着在 <code>isKindOfClass</code> 中有一个循环，先判断 <code>class</code> 是否等于 <code>meta class</code>，不等就继续循环判断是否等于 <code>super class</code>，不等再继续取 <code>super class</code>，如此循环下去。</p>
<p>在这里，<code>cls</code> 就是 <code>NSObject</code> 本身，执行这个方法后，第一次 <code>for</code> 循环时，先执行 <code>object_getClass</code> 这个方法，参数 <code>self</code> 指的是接收者，也就是 <code>NSObject</code>，这个方法返回 <code>NSObject-&gt;getIsa()</code>，然后调到 <code>getIsa()</code> 这个方法，这个方法返回 <code>NSObject</code> 的 <code>isa</code>，也就是元类 <code>meta class</code> 的指针。此时 <code>tcls = NSObject -&gt; meta class</code>， 然后判断 <code>tcls</code> 是否存在，存在就进入循环，判断 <code>tcls == cls</code>，还记得之前那张图吗？ <code>NSObject</code> 的元类并不是它本身，<code>NSObject -&gt; meta class != NSObject</code>。所以第一次判断不满足，继续进入循环，找到 <code>tcls -&gt; superclass</code>，<code>NSObject -&gt; meta class -&gt; superclass == NSObejct</code>，这还是上面那张图的只是。此时判定正确，返回 <code>YES</code>。所以第一行输出应该为 <code>YES</code>。</p>
<p>同理，分析第二句话：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">BOOL res3 = [(id)[Sark class] isKindOfClass:[Sark class]];</div></pre></td></tr></table></figure>
<p>这行代码的分析方法一样。</p>
<p><code>[Sark class]</code> 返回 <code>Sark</code> 类本身。执行<code>isKindOfClass</code>，<code>Sark</code> 类本身不等于 <code>Sark -&gt; meta class</code>，第一次循环失败；进入第二次循环，寻找父类，<code>Sark -&gt; meta class -&gt; superclass == NSObject -&gt; meta class</code>，<code>Sark != NSObject -&gt; meta class</code>，第二次循环失败；进入第三次循环，寻找父类，<code>NSObject -&gt; meta class -&gt; superclass == NSObject</code>，<code>Sark != NSObject</code>，第三次循环失败；进入第四次循环，<code>NSObject -&gt; superclass == nil</code>，此时 <code>tcls == nil</code>了，直接退出循环，返回 <code>NO</code>。</p>
<p>如果这个地方改成</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">BOOL res3 = [sark isKindOfClass:[Sark class]];</div></pre></td></tr></table></figure>
<p><code>sark</code> 是类 <code>Sark</code> 的一个实例，那么会返回 <code>YES</code>。因为方法中首先取 <code>[self class]</code> 的返回值作为 <code>tcls</code> 的值进行判断，而 <code>[sark class]</code> 就返回 <code>Sark</code>（实例对象的 <code>isa</code> 就是指向自己的类），所以第一次判断该的时候 <code>tcls = Sark</code>，<code>cls = Sark</code>，直接就返回 <code>YES</code>。</p>
<p>然后，我们看下 <code>+ isMenberOfClass</code>，从源码可以看到这个方法直接比较接收者的元类与参数的类是否一样。</p>
<p>那就很简单，不多说了，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">BOOL res2 = [(id)[NSObject class] isMemberOfClass:[NSObject class]];</div><div class="line">BOOL res4 = [(id)[Sark class] isMemberOfClass:[Sark class]];</div></pre></td></tr></table></figure>
<p><code>NSObject</code> 的元类是 <code>NSObject -&gt; meta class</code>，与 <code>NSObject</code> 不相等，返回 <code>NO</code>。</p>
<p><code>Sark</code> 的元类是 <code>Sark -&gt; meta class</code>，与 <code>Sark</code> 不相等，返回 <code>NO</code>。</p>
<p>我们再来看 <code>- isMenberOfClass</code>，从源码可以看到这个方法直接比较接收者的类与参数的类是否一样。</p>
<p>所以假如我们换成下面这种写法呢？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">BOOL res4 = [sark isMemberOfClass:[Sark class]];</div></pre></td></tr></table></figure>
<p><code>sark</code> 的类是 <code>Sark</code>，与 <code>Sark</code> 相等，返回 <code>YES</code>。</p>
<h4 id="练习-三-Class-与内存地址"><a href="#练习-三-Class-与内存地址" class="headerlink" title="练习(三) Class 与内存地址"></a>练习(三) <code>Class</code> 与内存地址</h4><p>再看一道题：</p>
<blockquote>
<p>下面的代码会？Compile Error / Runtime Crash / NSLog…?</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">@interface Sark : NSObject</div><div class="line">@property (nonatomic, copy) NSString *name;</div><div class="line">- (void)speak;</div><div class="line">@end</div><div class="line">&gt;</div><div class="line">@implementation Sark</div><div class="line">- (void)speak &#123;</div><div class="line">    NSLog(@&quot;my name&apos;s %@&quot;, self.name);</div><div class="line">&#125;</div><div class="line">@end</div><div class="line">&gt;</div><div class="line">@implementation ViewController</div><div class="line">- (void)viewDidLoad &#123;</div><div class="line">    [super viewDidLoad];</div><div class="line">    id cls = [Sark class];</div><div class="line">    /*</div><div class="line">    void *：void指针，一般被称为通用指针或泛指针，它是C关于“纯粹地址(raw address)”的一种约定。</div><div class="line">    当进行纯粹的内存操作时，或者传递一个指向未定类型的指针时，可以使用void指针。void指针也常常用作函数指针。</div><div class="line">    */</div><div class="line">    void *obj = &amp;cls;</div><div class="line">    /*</div><div class="line">    __bridge id：在ARC环境下，使用 __bridge 关键字来实现id类型与void*类型的相互转换</div><div class="line">    */</div><div class="line">    [(__bridge id)obj speak];</div><div class="line">&#125;</div><div class="line">@end</div></pre></td></tr></table></figure>
</blockquote>
<p>这道题有两个难点。难点一，<code>obj</code> 调用 <code>speak</code> 方法，到底会不会崩溃。难点二，如果 <code>speak</code> 方法不崩溃，应该输出什么？</p>
<p>分别来看：</p>
<p>难点一：不会崩溃，为什么？</p>
<p>代码中使用 <code>[Sark class]</code> 这句话获得了指向 <code>Sark</code> 类的指针，并赋值给 <code>cls</code>，然后 <code>cls</code> 被强制转换为了 <code>id</code> 类型，根据前面的知识， <code>id</code> 类型其实是一个指向类实例的指针。所以这时候 <code>cls</code> 就是一个指向 <code>Sark</code> 类实例的指针，所以 <code>obj</code> 就是这个类实例，理所应当的一个类实例可以调用这个类的类方法。</p>
<p>难点二：应该输出什么？</p>
<p>我们看下 <code>speak</code> 这个方法，打印了 <code>self.name</code>，这个 <code>self</code> 是什么才是关键。根据之前学到的知识，<code>self</code> 其实是消息传递的时候的一个隐藏参数，代表了消息接收者。</p>
<p>首先我们了解下栈的概念。在计算机系统中，运行的应用程序的数据都是保存在内存中的，不同类型的数据，保存的内存区域不同。栈区(stack) 由编译器自动分配并释放，存放函数的参数值，局部变量等。栈是系统数据结构，对应线程/进程是唯一的。</p>
<p>栈存储每一个函数在执行的时候都会向操作系统索要资源，栈区就是函数运行时的内存，栈区中的变量由编译器负责分配和释放，内存随着函数的运行分配，随着函数的结束而释放，由系统自动完成。</p>
<p>当执行 <code>- (void)viewDidLoad</code> 方法的时候会分配给一个栈区，这个栈去会保存函数的参数以及一些局部变量，那我们看下栈区里面到底有些什么。</p>
<ul>
<li><p>首先是函数的参数，由于 <code>viewDidLoad</code> 方法并没有参数，所以入栈的仅仅只有两个隐藏参数，<code>self</code> 和 <code>_cmd</code>；</p>
</li>
<li><p>其次执行第一行代码，是一个方法，<code>objc_msgSendSuper</code> 有两个参数 <code>objc_super</code> 和 方法选择器 <code>SEL</code>，由于[super viewDidLoad] 这个方法执行的时候，runtime 会转换成 objc_msgSendSuper2(objc_super, @selector(viewDidLoad))，实际方法的接收者是 self，但是会去父类查找这个方法实现，所以相当于 <code>objc_msgSendSuper</code> 这个方法调用了 <code>viewDidLoad</code> 方法，这个方法的 <code>SEL</code> 已经有了，不需要栈空间再次为它分配地址。这里就只分配 <code>objc_super</code> 空间，这个结构体里有俩变量需要分配，一个 <code>self</code>，一个 <code>super_class</code>。</p>
</li>
<li><p>然后 <code>id cls = [Sark class];</code>，生成一个局部变量，入栈。</p>
</li>
<li><p>然后 <code>void *obj = &amp;cls;</code>，又是一个局部变量，分配空间，入栈。</p>
</li>
<li><p>最后 <code>[(__bridge id)obj speak];</code> 这行代码，转换为 <code>objc_msgSend(obj, @selector(speak))</code>，查找 <code>speak</code> 的方法实现，在 <code>Sark</code> 类中找到，需要打印出属性 <code>name</code>，在调用 <code>self.name</code> 的时候，本质上是 <code>self</code> 指针在内存向高位地址偏移一个指针。</p>
</li>
<li><p>最后你可以根据打印出来的地址，得出打印结果为 <strong><code>my name&#39;s &lt;ViewController: 0x7faaace052a0&gt;</code></strong> 。</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">@implementation ViewController</div><div class="line"></div><div class="line">- (void)viewDidLoad &#123;</div><div class="line">    [super viewDidLoad];</div><div class="line">    </div><div class="line">    NSLog(@&quot;ViewController = %@ , 地址 = %p&quot;, self, &amp;self);</div><div class="line">    </div><div class="line">    NSLog(@&quot;self = %p, _cmd = %p&quot;, &amp;self, &amp;_cmd);</div><div class="line">    </div><div class="line">    id cls = [Sark class];</div><div class="line">    NSLog(@&quot;Sark class/cls = %@ 地址/cls = %p&quot;, cls, &amp;cls);</div><div class="line">    </div><div class="line">    void *obj = &amp;cls;</div><div class="line">    NSLog(@&quot;Void *obj/obj = %@ 地址obj = %p&quot;, obj, &amp;obj);</div><div class="line">    </div><div class="line">    [(__bridge id)obj speak];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)didReceiveMemoryWarning &#123;</div><div class="line">    [super didReceiveMemoryWarning];</div><div class="line">    // Dispose of any resources that can be recreated.</div><div class="line">&#125;</div><div class="line">@end</div><div class="line"></div><div class="line">/*</div><div class="line">2017-01-13 15:52:10.150 runtime[59122:3287610] ViewController = &lt;ViewController: 0x7ffc58506760&gt; , 地址 = 0x7fff5e17baa8</div><div class="line">2017-01-13 15:52:10.151 runtime[59122:3287610] self = 0x7fff5e17baa8, _cmd = 0x7fff5e17baa0</div><div class="line">2017-01-13 15:52:10.152 runtime[59122:3287610] Sark class/cls = Sark 地址/cls = 0x7fff5e17ba88</div><div class="line">2017-01-13 15:52:10.152 runtime[59122:3287610] Void *obj/obj = &lt;Sark: 0x7fff5e17ba88&gt; 地址obj = 0x7fff5e17ba80</div><div class="line">2017-01-13 15:52:10.153 runtime[59122:3287610] my name&apos;s &lt;ViewController: 0x7ffc58506760&gt;, 0x7fff5e17ba48, 0x7fff5e17ba90</div><div class="line">*/</div></pre></td></tr></table></figure>
<p>这里我们把地址都打印出来，<code>self.name</code> 其实就是 <code>self</code> 的指针向高位地址偏移一个指针。一个指针是4位，所以应该是 <code>self</code> 的地址 加上 32 bits。</p>
<p>那么 <code>self</code> 的地址是多少呢？</p>
<p>我们知道 <code>self</code> 实际上应该是 <code>Sark</code> 类的地址，<code>obj</code> 是 <code>Sark</code> 的一个实例，它的 <code>isa</code> 指针指向的就是 <code>Sark</code> 类，也就是 <code>cls</code> 这个变量的地址，从结果也印证了这点，<code>obj</code> 的地址是 <code>0x7fff5e17ba80</code>， <code>cls</code> 的地址是 <code>0x7fff5e17ba88</code>，这个地址向高位偏移一个指针，也就是32 bits，加上就是 <code>0x7fff5e17baa8</code>，这个地址打印出来的东西就是 <code>&lt;ViewController: 0x7ffc58506760&gt;</code>。</p>
<blockquote>
<p>参考这篇<a href="http://www.jianshu.com/p/f725d2828a2f" target="_blank" rel="external">文章</a>加深理解。</p>
<p>这道题还有点疑惑，待解决。</p>
</blockquote>
<h3 id="获取方法地址"><a href="#获取方法地址" class="headerlink" title="获取方法地址"></a>获取方法地址</h3><p>我们可以避开消息绑定而直接获取方法地址来调用方法，这种做法非常适合大量重复调用某方法的极端情况，避开消息发送泛滥而直接调用该方法会更高效。在 <code>IMP</code> 那一节，已经给出例子了。</p>
<p>这里再给出一个例子:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">void (*setter)(id, SEL, BOOL);</div><div class="line">int i;</div><div class="line"> </div><div class="line">setter = (void (*)(id, SEL, BOOL))[target</div><div class="line">    methodForSelector:@selector(setFilled:)];</div><div class="line">for ( i = 0 ; i &lt; 1000 ; i++ )</div><div class="line">    setter(targetList[i], @selector(setFilled:), YES);</div></pre></td></tr></table></figure>
<p>当方法被当做函数调用时，上节提到的两个隐藏参数就需要我们明确给出了。</p>
<h2 id="动态方法解析"><a href="#动态方法解析" class="headerlink" title="动态方法解析"></a>动态方法解析</h2>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h2&gt;&lt;p&gt;上一篇文章讨论了 &lt;code&gt;Swift&lt;/code&gt; 下如何实现 &lt;code&gt;Runtime&lt;/code&gt; 的一些实际应用，那么这篇文章索性了解下 &lt;code&gt;iOS&lt;/code&gt; 的 &lt;code&gt;Runtime&lt;/code&gt; 机制。&lt;/p&gt;
&lt;p&gt;虽然 &lt;code&gt;Swift&lt;/code&gt; 作为一门编程语言是不具有动态性的，使用 &lt;code&gt;Swift&lt;/code&gt; 编写的代码，在编译时就确定了调用那个函数，而不是 &lt;code&gt;Objective-C&lt;/code&gt; 的运行时发消息，它采用的是类似 &lt;code&gt;C++&lt;/code&gt; 的 &lt;code&gt;vtable&lt;/code&gt;，这样的机制确保了 &lt;code&gt;Swift&lt;/code&gt; 代码运行的更快，然而由于 &lt;code&gt;iOS&lt;/code&gt; 的核心框架 &lt;code&gt;Cocoa&lt;/code&gt; 是使用 &lt;code&gt;Objective-C&lt;/code&gt; 编写的，而 &lt;code&gt;Swift&lt;/code&gt; 为了向 &lt;code&gt;Objective-C&lt;/code&gt; 兼容，也做了很多妥协，因此还是有必要了解下 &lt;code&gt;Objective-C&lt;/code&gt; 的 &lt;code&gt;Runtime&lt;/code&gt; 机制。&lt;/p&gt;
    
    </summary>
    
      <category term="编程" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="iOS" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B/iOS/"/>
    
    
      <category term="编程" scheme="http://yoursite.com/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="iOS" scheme="http://yoursite.com/tags/iOS/"/>
    
      <category term="Swift" scheme="http://yoursite.com/tags/Swift/"/>
    
      <category term="Runtime" scheme="http://yoursite.com/tags/Runtime/"/>
    
      <category term="Objective-C" scheme="http://yoursite.com/tags/Objective-C/"/>
    
  </entry>
  
  <entry>
    <title>iOS中的Runtime-Swift(使用篇)</title>
    <link href="http://yoursite.com/2017/01/05/iOS%E4%B8%AD%E7%9A%84Runtime-Swift/"/>
    <id>http://yoursite.com/2017/01/05/iOS中的Runtime-Swift/</id>
    <published>2017-01-05T06:01:26.000Z</published>
    <updated>2017-01-09T06:58:31.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>使用 Obejective-C 开发 iOS 程序的同学一定对 Runtime 运行时机制不陌生，由于 Obejective-C 是一门动态语言，它会将一些工作从编译时推迟到运行时。实际上，由于 Objective-C 的消息分发机制，所有使用 Objective-C 编写的函数或方法，本质上都是通过 Objective-C Runtime 的 <code>objc_msgSend</code> 函数发送的一个消息传递。于是，我们可以通过 Objective-C Runtime 机制的特点，来动态的改变函数的实现，实现 Method Swizzling，亦或是通过 category 来给类扩展存储属性。</p>
<a id="more"></a>
<p>但是，在 Swift 语言中，由于 Swift 已经没有了 Objective-C 的运行时消息机制了，在代码编译的时候，已经确定了实际调用的方法，所以纯粹的 Swift 类和对象是不能实现 Runtime 的，也就没有 Method Swizzling 了。</p>
<p>所幸，凡是皆有转机。为了兼容 Objective-C，凡是继承了 <code>NSObject</code> 的类，都会保留其动态性，依然会遵循 Obejective-C 的消息机制，这就给我们实现 Runtime 提供了可能性。</p>
<p>这篇文章将主要总结下在 Swift 中，Runtime 的几种常见使用。</p>
<blockquote>
<p><strong>请注意：仅仅在不得已的情况下才使用 runtime，随意修改基础框架或所使用的三方代码是毁掉你的应用的绝佳方法。请务必要小心哦</strong></p>
</blockquote>
<h2 id="Runtime-在-Swift-中的使用"><a href="#Runtime-在-Swift-中的使用" class="headerlink" title="Runtime 在 Swift 中的使用"></a>Runtime 在 Swift 中的使用</h2><h3 id="关联对象"><a href="#关联对象" class="headerlink" title="关联对象"></a>关联对象</h3><p>我们知道，在 Swift 的 extension 中，不能直接扩展存储属性，只能扩展计算型属性，而计算型属性的 setter 只能间接的设置其他属性或变量的值，不能直接设置自身的值，否则会引起死循环，无法通过编译。那么想要给类，结构体扩展存储属性就只能利用 Runtime 机制了。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123; &#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Person</span> </span>&#123;</div><div class="line">    <span class="keyword">var</span> age: <span class="type">Int</span> &#123;</div><div class="line">        <span class="keyword">get</span> &#123;</div><div class="line">            <span class="keyword">return</span> <span class="number">43</span></div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="keyword">set</span> &#123;</div><div class="line">            <span class="keyword">self</span>.age = newValue</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> jobs = <span class="type">Person</span>()</div><div class="line">jobs.age = <span class="number">44</span></div><div class="line"><span class="comment">// error: Playground execution aborted: error: Execution was interrupted, reason: EXC_BAD_ACCESS (code=2, address=0x7fff5f3ffff8).</span></div><div class="line"><span class="comment">// The process has been left at the point where it was interrupted, use "thread return -x" to return to the state before expression evaluation.</span></div></pre></td></tr></table></figure>
<p>想要实现给类，结构体扩展存储属性，需要下面几个方法：</p>
<ul>
<li><p><code>objc_setAssociatedObject(_ object: Any!, _ key: UnsafeRawPointer!, _ value: Any!, _ policy: objc_AssociationPolicy)</code></p>
</li>
<li><p><code>objc_getAssociatedObject(_ object: Any!, _ key: UnsafeRawPointer!) -&gt; Any!</code></p>
</li>
<li><p><code>objc_removeAssociatedObjects(_ object: Any!)</code></p>
</li>
</ul>
<p>这三个方法很类似，一个用于 set，一个用于 get，一个用于 remove。</p>
<ul>
<li><p><code>objc_setAssociatedObject(_ object: Any!, _ key: UnsafeRawPointer!, _ value: Any!, _ policy: objc_AssociationPolicy)</code> 方法讲使用给定的 key 和关联策略来给一个对象设置一个关联</p>
</li>
<li><p><code>objc_getAssociatedObject(_ object: Any!, _ key: UnsafeRawPointer!) -&gt; Any!</code> 方法将返回一个对象的关联值，这个关联值之前通过相同的 key 值设置过关联。</p>
</li>
<li><p><code>objc_removeAssociatedObjects(_ object: Any!)</code> 方法会移除一个对象所有的关联，参数 <code>object</code> 是需要移除关联的那个对象。</p>
</li>
</ul>
<p>那么看下具体的例子：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 不推荐</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123; &#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Person</span> </span>&#123;</div><div class="line">    <span class="keyword">var</span> age: <span class="type">Int</span> &#123;</div><div class="line">        <span class="keyword">get</span> &#123;</div><div class="line">            <span class="keyword">return</span> objc_getAssociatedObject(<span class="keyword">self</span>, <span class="string">"age"</span>) <span class="keyword">as</span>! <span class="type">Int</span></div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="keyword">set</span> &#123;</div><div class="line">            objc_setAssociatedObject(<span class="keyword">self</span>, <span class="string">"age"</span>, newValue, .<span class="type">OBJC_ASSOCIATION_RETAIN_NONATOMIC</span>)</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> jobs = <span class="type">Person</span>()</div><div class="line">jobs.age = <span class="number">44</span></div><div class="line"><span class="built_in">print</span>(jobs.age)</div><div class="line"><span class="comment">// fatal error: unexpectedly found nil while unwrapping an Optional value</span></div></pre></td></tr></table></figure>
<p>上面这种写法是最直接的写法。但是这种写法有一个问题，就是会崩溃。</p>
<p>具体的原因<a href="http://www.jianshu.com/p/53abf1703905" target="_blank" rel="external">这篇文章</a>已经给出了答案。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 推荐</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123; &#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Person</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">struct</span> <span class="title">AssociaKey</span></span>&#123;</div><div class="line">        <span class="keyword">static</span> <span class="keyword">var</span> <span class="type">Age</span>: <span class="type">String</span> = <span class="string">"age"</span></div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">var</span> age: <span class="type">Int</span> &#123;</div><div class="line">        <span class="keyword">get</span> &#123;</div><div class="line">            <span class="keyword">return</span> objc_getAssociatedObject(<span class="keyword">self</span>, &amp;<span class="type">AssociaKey</span>.<span class="type">Age</span>) <span class="keyword">as</span>! <span class="type">Int</span></div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="keyword">set</span> &#123;</div><div class="line">            objc_setAssociatedObject(<span class="keyword">self</span>, &amp;<span class="type">AssociaKey</span>.<span class="type">Age</span>, newValue , .<span class="type">OBJC_ASSOCIATION_RETAIN_NONATOMIC</span>)</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> jobs = <span class="type">Person</span>()</div><div class="line">jobs.age = <span class="number">44</span></div><div class="line"><span class="built_in">print</span>(<span class="string">"jobs'age is <span class="subst">\(jobs.age)</span>"</span>)</div><div class="line"><span class="comment">// jobs'age is 44</span></div></pre></td></tr></table></figure>
<blockquote>
<p>注意，在私有嵌套 <code>struct</code> 中使用 <code>static var</code>，这样会生成我们所需的关联对象键，但不会污染整个命名空间。</p>
<p>大家常见的 MJRefresh（OC）上拉下拉等刷新框架，就是通过这种方式，给 <code>tableView</code> 添加一个<code>mj_header</code>、 <code>mj_footer</code></p>
</blockquote>
<h3 id="方法交叉（Method-Swizzling）"><a href="#方法交叉（Method-Swizzling）" class="headerlink" title="方法交叉（Method Swizzling）"></a>方法交叉（Method Swizzling）</h3><p>有时候，为了解决某些第三方框架里的 bug，我们需要修改一个已经存在的类的方法的行为，这时候我们就会利用方法交叉，方法交叉可以让你交换两个方法的实现，相当于是用你写的方法来重载原有方法，并且还能够是原有方法的行为保持不变。</p>
<p>还有另一种场景，系统自带的方法已经不能满足我们的需求，我们需要在保证系统方法原有的基础上，给其扩展一些功能。这时候有两种方法来实现需求：</p>
<ul>
<li><p>自定义一个子类，重写父类的方法，然后实现我们需要的功能。</p>
</li>
<li><p>利用方法交叉，我们自己定义一个方法，在这个方法里实现所需要的功能，并且调用系统原有的方法，然后利用 Runtime 交换系统的方法，这样在调用系统的方法的时候，实际上是调用的我们自己写的方法。</p>
</li>
</ul>
<p>想要在 Swift(3.0) 中实现方法交叉，有下面几个关键点：</p>
<ul>
<li>在 Objective-C 中，我们使用 <code>category</code> 的 <code>+load</code> 方法作为 Method Swizzling 的载体，因为 <code>+load</code> 方法只会被调用一次，这可以确保我们的方法交互只进行一次，然而在 Swift 中，<code>extension</code> 并不是运行时加载的，所以也就没有在运行时会被加载的类似于 <code>+load</code> 的方法。所以我们需要另一个初始化时就会被调用的方法作为载体方法，在 Swift 中，我们使用下面这个方法</li>
</ul>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">open <span class="keyword">override</span> <span class="class"><span class="keyword">class</span> <span class="title">func</span> <span class="title">initialize</span>() </span>&#123;</div><div class="line">	<span class="comment">// Method Swizzling</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li><p>在 Swift3.0 之前我们使用 <code>dispatch_once_t</code> 来确保方法只会被交换一次，但3.0之后，这个方法已经不可用了，下面三种方式可以替代：</p>
<ol>
<li><p>全局变量(Global variable)</p>
</li>
<li><p>结构体、枚举或者类的静态属性(Static property of <code>struct</code>, <code>enum</code> or <code>class</code>)</p>
</li>
<li><p>扩展 <code>DispatchQueue</code>，实现 <code>Dispatch once</code> 原有的功能</p>
</li>
</ol>
</li>
<li><p>交换系统类和自定义类里的方法，实现方式不同。对系统类，比如 <code>UIViewController</code>，可以直接进行交换，对于自定义类，有两个地方需要注意：</p>
<ol>
<li><p>包含 swizzle 方法的类需要继承自 <code>NSObject</code></p>
</li>
<li><p>如果要 Swizzle 的是 Swift 类型的方法的话，需要将原方法和替换方法都加上 <code>dynamic</code> 标记，以指明它们需要使用动态派发机制。</p>
<p>这主要是因为 Method Swizzling 的实现是基于 <code>Objective-C</code> 的动态派发机制,所以有这两条限制。</p>
</li>
</ol>
</li>
</ul>
<p>实现 Method Swizzling 会涉及到下面这六个方法：</p>
<ul>
<li><p><code>class_getInstanceMethod(_ cls: Swift.AnyClass!, _ name: Selector!) -&gt; Method!)</code></p>
</li>
<li><p><code>class_addMethod(_ cls: Swift.AnyClass!, _ name: Selector!, _ imp: IMP!, _ types: UnsafePointer&lt;Int8&gt;!) -&gt; Bool</code></p>
</li>
<li><p><code>class_replaceMethod(_ cls: Swift.AnyClass!, _ name: Selector!, _ imp: IMP!, _ types: UnsafePointer&lt;Int8&gt;!) -&gt; IMP!</code></p>
</li>
<li><p><code>method_getImplementation(_ m: Method!) -&gt; IMP!</code></p>
</li>
<li><p><code>method_getTypeEncoding(_ m: Method!) -&gt; UnsafePointer&lt;Int8&gt;!</code></p>
</li>
<li><p><code>method_exchangeImplementations(_ m1: Method!, _ m2: Method!)</code></p>
</li>
</ul>
<p>方法不解释了，苹果的命名规范很好，一看就懂，还不懂得花可以去看下文档，解释的很清晰。</p>
<p>那么，需要注意的点说完了，下面我们还是用一个例子还说明在 Swift 中实现方法交叉。</p>
<h4 id="系统类的方法交叉"><a href="#系统类的方法交叉" class="headerlink" title="系统类的方法交叉"></a>系统类的方法交叉</h4><h5 id="1-使用全局变量解决-dispatch-once-t的问题"><a href="#1-使用全局变量解决-dispatch-once-t的问题" class="headerlink" title="1. 使用全局变量解决 dispatch_once_t的问题"></a>1. 使用全局变量解决 <code>dispatch_once_t</code>的问题</h5><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> UIKit</div><div class="line"></div><div class="line"><span class="keyword">private</span> <span class="keyword">let</span> swizzling: (<span class="type">UIViewController</span>.<span class="type">Type</span>) -&gt; () = &#123; viewController <span class="keyword">in</span></div><div class="line">    <span class="keyword">let</span> originalSelector = #selector(viewController.viewWillAppear(<span class="number">_</span>:))</div><div class="line">    <span class="keyword">let</span> swizzledSelector = #selector(viewController.newViewWillAppear(animated:))</div><div class="line">    </div><div class="line">    <span class="keyword">let</span> originalMethod = class_getInstanceMethod(viewController, originalSelector)</div><div class="line">    <span class="keyword">let</span> swizzledMethod = class_getInstanceMethod(viewController, swizzledSelector)</div><div class="line">    </div><div class="line">    <span class="comment">//在进行 Swizzling 的时候,需要用 class_addMethod 先进行判断一下原有类中是否有要替换方法的实现</span></div><div class="line">    <span class="keyword">let</span> didAddMethod = class_addMethod(viewController, originalSelector, method_getImplementation(swizzledMethod), method_getTypeEncoding(swizzledMethod))</div><div class="line">    </div><div class="line">    <span class="comment">// 这里解释下 class_addMethod 方法，这个方法会给类添加一个新的方法（通过给定的方法名字和方法实现），但是在添加之前首先会判断类中是否已经实现了这个方法（其实就是检查selector是否有对应的implementation），如果已经有了实现，则会返回no，如果没有实现，那么会去检查父类，并且在当前类添加一个父类的重载函数，使用参数中的 Sel 和 IMP。</span></div><div class="line">	<span class="comment">// 如果 class_addMethod 返回 no, 说明当前类中已经有 viewWillApear 方法的实现，这时候只需要直接交换两个方法的实现即可，原来的 viewWillAppear 方法名称实现的是自己实现的 sa_ViewWillAppear 方法，sa_ViewWillAppear 实现的是原来的viewWillAppear。</span></div><div class="line">	<span class="comment">// 如果 class_addMethod 返回 yes, 说明当前类中没有要需要替换的方法的实现,所以需要在父类中查找,这时候就用到 method_getImplemetation 去获取 class_getInstanceMethod 里面的方法实现, 实际上 originalSelector 指向的是父类的方法，class_addMethod 方法会添加一个重载父类方法的新方法，新方法名字为 originalSelector，方法实现是 swizzledMethod，然后再进行 class_replaceMethod 将swizzledSelector 这个方法名字的实现替换为原来父类中的方法实现 originalMethod，这样就达到了我们自定义方法中调用父类实现的目的，从而实现 Swizzing</span></div><div class="line">    <span class="keyword">if</span> didAddMethod &#123;</div><div class="line">        class_replaceMethod(viewController, swizzledSelector, method_getImplementation(originalMethod), method_getTypeEncoding(originalMethod))</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        method_exchangeImplementations(originalMethod, swizzledMethod);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ViewController</span>: <span class="title">UIViewController</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</div><div class="line">        <span class="keyword">super</span>.viewDidLoad()</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">didReceiveMemoryWarning</span><span class="params">()</span></span> &#123;</div><div class="line">        <span class="keyword">super</span>.didReceiveMemoryWarning()</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">extension</span> <span class="title">UIViewController</span> </span>&#123;</div><div class="line">    open <span class="keyword">override</span> <span class="class"><span class="keyword">class</span> <span class="title">func</span> <span class="title">initialize</span>() </span>&#123;</div><div class="line">        <span class="comment">// make sure this isn't a subclass</span></div><div class="line">        <span class="keyword">guard</span> <span class="keyword">self</span> === <span class="type">UIViewController</span>.<span class="keyword">self</span> <span class="keyword">else</span> &#123; <span class="keyword">return</span> &#125;</div><div class="line">        swizzling(<span class="keyword">self</span>)</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">// MARK: - Method Swizzling</span></div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">sa_ViewWillAppear</span><span class="params">(animated: Bool)</span></span> &#123;</div><div class="line">		<span class="comment">// 这里方法实现已经进行了替换，sa_ViewWillAppear 实际上实现的是 ViewWillAppear 方法的实现</span></div><div class="line">        <span class="keyword">self</span>.sa_ViewWillAppear(animated: animated)</div><div class="line">        <span class="keyword">let</span> viewControllerName = <span class="type">NSStringFromClass</span>(type(of: <span class="keyword">self</span>))</div><div class="line">        <span class="built_in">print</span>(<span class="string">"Swizzling viewWillAppear: <span class="subst">\(viewControllerName)</span>"</span>)</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">// Swizzling viewWillAppear: methodSwizzling.ViewController</span></div></pre></td></tr></table></figure>
<h5 id="2-使用结构体、枚举或者类的静态属性-Static-property-of-struct-enum-or-class-解决-dispatch-once-t的问题"><a href="#2-使用结构体、枚举或者类的静态属性-Static-property-of-struct-enum-or-class-解决-dispatch-once-t的问题" class="headerlink" title="2. 使用结构体、枚举或者类的静态属性(Static property of struct, enum or class)解决 dispatch_once_t的问题"></a>2. 使用结构体、枚举或者类的静态属性(Static property of struct, enum or class)解决 <code>dispatch_once_t</code>的问题</h5><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> UIKit</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ViewController</span>: <span class="title">UIViewController</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</div><div class="line">        <span class="keyword">super</span>.viewDidLoad()</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">didReceiveMemoryWarning</span><span class="params">()</span></span> &#123;</div><div class="line">        <span class="keyword">super</span>.didReceiveMemoryWarning()</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">extension</span> <span class="title">UIViewController</span> </span>&#123;</div><div class="line">    open <span class="keyword">override</span> <span class="class"><span class="keyword">class</span> <span class="title">func</span> <span class="title">initialize</span>() </span>&#123;</div><div class="line">        <span class="comment">// make sure this isn't a subclass</span></div><div class="line">        <span class="keyword">guard</span> <span class="keyword">self</span> === <span class="type">UIViewController</span>.<span class="keyword">self</span> <span class="keyword">else</span> &#123; <span class="keyword">return</span> &#125;</div><div class="line">        </div><div class="line">        <span class="keyword">let</span> <span class="number">_</span>: () = &#123;</div><div class="line">            <span class="keyword">let</span> originalSelector = #selector(<span class="keyword">self</span>.viewWillAppear(<span class="number">_</span>:))</div><div class="line">            <span class="keyword">let</span> swizzledSelector = #selector(<span class="keyword">self</span>.sa_ViewWillAppear(animated:))</div><div class="line">            </div><div class="line">            <span class="keyword">let</span> originalMethod = class_getInstanceMethod(<span class="keyword">self</span>, originalSelector)</div><div class="line">            <span class="keyword">let</span> swizzledMethod = class_getInstanceMethod(<span class="keyword">self</span>, swizzledSelector)</div><div class="line">            </div><div class="line">            <span class="keyword">let</span> didAddMethod = class_addMethod(<span class="keyword">self</span>, originalSelector, method_getImplementation(swizzledMethod), method_getTypeEncoding(swizzledMethod))</div><div class="line">            </div><div class="line">            <span class="keyword">if</span> didAddMethod &#123;</div><div class="line">                class_replaceMethod(<span class="keyword">self</span>, swizzledSelector, method_getImplementation(originalMethod), method_getTypeEncoding(originalMethod))</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                method_exchangeImplementations(originalMethod, swizzledMethod);</div><div class="line">            &#125;</div><div class="line">        &#125;()</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">// MARK: - Method Swizzling</span></div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">sa_ViewWillAppear</span><span class="params">(animated: Bool)</span></span> &#123;</div><div class="line">        <span class="keyword">self</span>.sa_ViewWillAppear(animated: animated)</div><div class="line">        <span class="keyword">let</span> viewControllerName = <span class="type">NSStringFromClass</span>(type(of: <span class="keyword">self</span>))</div><div class="line">        <span class="built_in">print</span>(<span class="string">"Swizzling viewWillAppear: <span class="subst">\(viewControllerName)</span>"</span>)</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">// Swizzling viewWillAppear: methodSwizzling.ViewController</span></div></pre></td></tr></table></figure>
<h5 id="3-扩展-DispatchQueue，实现-Dispatch-once-原有的功能"><a href="#3-扩展-DispatchQueue，实现-Dispatch-once-原有的功能" class="headerlink" title="3. 扩展 DispatchQueue，实现 Dispatch once 原有的功能"></a>3. 扩展 <code>DispatchQueue</code>，实现 <code>Dispatch once</code> 原有的功能</h5><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> UIKit</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ViewController</span>: <span class="title">UIViewController</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</div><div class="line">        <span class="keyword">super</span>.viewDidLoad()</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">didReceiveMemoryWarning</span><span class="params">()</span></span> &#123;</div><div class="line">        <span class="keyword">super</span>.didReceiveMemoryWarning()</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">extension</span> <span class="title">UIViewController</span> </span>&#123;</div><div class="line">    open <span class="keyword">override</span> <span class="class"><span class="keyword">class</span> <span class="title">func</span> <span class="title">initialize</span>() </span>&#123;</div><div class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">Static</span> </span>&#123;</div><div class="line">            <span class="keyword">static</span> <span class="keyword">var</span> token = <span class="type">NSUUID</span>().uuidString</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="comment">// make sure this isn't a subclass</span></div><div class="line">        <span class="keyword">guard</span> <span class="keyword">self</span> === <span class="type">UIViewController</span>.<span class="keyword">self</span> <span class="keyword">else</span> &#123; <span class="keyword">return</span> &#125;</div><div class="line">        </div><div class="line">        <span class="type">DispatchQueue</span>.once(token: <span class="type">Static</span>.token) &#123; </div><div class="line">            <span class="keyword">let</span> originalSelector = #selector(<span class="keyword">self</span>.viewWillAppear(<span class="number">_</span>:))</div><div class="line">            <span class="keyword">let</span> swizzledSelector = #selector(<span class="keyword">self</span>.sa_ViewWillAppear(animated:))</div><div class="line">            </div><div class="line">            <span class="keyword">let</span> originalMethod = class_getInstanceMethod(<span class="keyword">self</span>, originalSelector)</div><div class="line">            <span class="keyword">let</span> swizzledMethod = class_getInstanceMethod(<span class="keyword">self</span>, swizzledSelector)</div><div class="line">            </div><div class="line">            <span class="keyword">let</span> didAddMethod = class_addMethod(<span class="keyword">self</span>, originalSelector, method_getImplementation(swizzledMethod), method_getTypeEncoding(swizzledMethod))</div><div class="line">            </div><div class="line">            <span class="keyword">if</span> didAddMethod &#123;</div><div class="line">                class_replaceMethod(<span class="keyword">self</span>, swizzledSelector, method_getImplementation(originalMethod), method_getTypeEncoding(originalMethod))</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                method_exchangeImplementations(originalMethod, swizzledMethod);</div><div class="line">            &#125;</div><div class="line"></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">// MARK: - Method Swizzling</span></div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">sa_ViewWillAppear</span><span class="params">(animated: Bool)</span></span> &#123;</div><div class="line">        <span class="keyword">self</span>.sa_ViewWillAppear(animated: animated)</div><div class="line">        <span class="keyword">let</span> viewControllerName = <span class="type">NSStringFromClass</span>(type(of: <span class="keyword">self</span>))</div><div class="line">        <span class="built_in">print</span>(<span class="string">"Swizzling viewWillAppear: <span class="subst">\(viewControllerName)</span>"</span>)</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">extension</span> <span class="title">DispatchQueue</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">var</span> onceTracker = [<span class="type">String</span>]()</div><div class="line">    open <span class="class"><span class="keyword">class</span> <span class="title">func</span> <span class="title">once</span>(<span class="title">token</span>: <span class="title">String</span>, <span class="title">block</span>:() -&gt; <span class="title">Void</span>) </span>&#123;</div><div class="line">        objc_sync_enter(<span class="keyword">self</span>)</div><div class="line">        <span class="keyword">defer</span> &#123;</div><div class="line">            objc_sync_exit(<span class="keyword">self</span>)</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="keyword">if</span> onceTracker.<span class="built_in">contains</span>(token) &#123;</div><div class="line">            <span class="keyword">return</span></div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        onceTracker.append(token)</div><div class="line">        block()</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这种方法参考<a href="http://stackoverflow.com/questions/37886994/dispatch-once-in-swift-3" target="_blank" rel="external">StackOverFlow</a>。但是略显繁琐，建议可以选取前两种方法任意一种即可。</p>
<p>关于每句话的含义，代码段里已经有了清晰的解释了，请阅读。</p>
<h4 id="自定义类的方法交叉"><a href="#自定义类的方法交叉" class="headerlink" title="自定义类的方法交叉"></a>自定义类的方法交叉</h4><p>有时候我们需要实现自定义类的的方法交叉，这时候大体上与系统类方法交叉一样，但有两点需要注意。上面已经说过了，这里再说一次：</p>
<ol>
<li><p>包含 swizzle 方法的类需要继承自 <code>NSObject</code></p>
</li>
<li><p>如果要 Swizzle 的是 Swift 类型的方法的话，需要将原方法和替换方法都加上 <code>dynamic</code> 标记，以指明它们需要使用动态派发机制。</p>
</li>
</ol>
<p>以上也决定了，你不能对一个你没有声明的方法进行交换。</p>
<p>例子最直观：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> UIKit</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ViewController</span>: <span class="title">UIViewController</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</div><div class="line">        <span class="keyword">super</span>.viewDidLoad()</div><div class="line">        <span class="keyword">let</span> ramsey = <span class="type">Programmer</span>()</div><div class="line">        <span class="keyword">let</span> wu = <span class="type">Doctor</span>()</div><div class="line">        ramsey.foo(<span class="literal">true</span>)</div><div class="line">        <span class="built_in">print</span>(<span class="string">"======="</span>)</div><div class="line">        ramsey.proj_foo(<span class="literal">true</span>)</div><div class="line">        <span class="built_in">print</span>(<span class="string">"======="</span>)</div><div class="line">        wu.foo(<span class="literal">true</span>)</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">didReceiveMemoryWarning</span><span class="params">()</span></span> &#123;</div><div class="line">        <span class="keyword">super</span>.didReceiveMemoryWarning()</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>: <span class="title">NSObject</span> </span>&#123;</div><div class="line">    <span class="keyword">var</span> name = <span class="string">"Person"</span></div><div class="line">    <span class="keyword">dynamic</span> <span class="function"><span class="keyword">func</span> <span class="title">foo</span><span class="params">(<span class="number">_</span> bar: Bool)</span></span> &#123;</div><div class="line">        <span class="built_in">print</span>(<span class="string">"Person.foo"</span>)</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Programmer</span>: <span class="title">Person</span> </span>&#123;</div><div class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">foo</span><span class="params">(<span class="number">_</span> bar: Bool)</span></span> &#123;</div><div class="line">        <span class="keyword">super</span>.foo(bar)</div><div class="line">        <span class="built_in">print</span>(<span class="string">"Programmer.foo"</span>)</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Doctor</span>: <span class="title">Person</span> </span>&#123;</div><div class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">foo</span><span class="params">(<span class="number">_</span> bar: Bool)</span></span> &#123;</div><div class="line">        <span class="keyword">super</span>.foo(bar)</div><div class="line">        <span class="built_in">print</span>(<span class="string">"Doctor.foo"</span>)</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Programmer</span> </span>&#123;</div><div class="line">    </div><div class="line">    open <span class="keyword">override</span> <span class="class"><span class="keyword">class</span> <span class="title">func</span> <span class="title">initialize</span>() </span>&#123;</div><div class="line">        <span class="comment">// Perform this one time only</span></div><div class="line">        <span class="keyword">let</span> <span class="number">_</span>: () = &#123;</div><div class="line">            <span class="keyword">let</span> originalSelector = #selector(<span class="type">Programmer</span>.foo(<span class="number">_</span>:))</div><div class="line">            <span class="keyword">let</span> swizzledSelector = #selector(<span class="type">Programmer</span>.proj_foo(<span class="number">_</span>:))</div><div class="line">            </div><div class="line">            <span class="keyword">let</span> originalMethod = class_getInstanceMethod(<span class="keyword">self</span>, originalSelector)</div><div class="line">            <span class="keyword">let</span> swizzledMethod = class_getInstanceMethod(<span class="keyword">self</span>, swizzledSelector)</div><div class="line">            </div><div class="line">            <span class="keyword">let</span> addMethod = class_addMethod(<span class="keyword">self</span>, originalSelector, method_getImplementation(swizzledMethod), method_getTypeEncoding(swizzledMethod))</div><div class="line">            </div><div class="line">            <span class="keyword">if</span> addMethod &#123;</div><div class="line">                class_replaceMethod(<span class="keyword">self</span>, swizzledSelector, method_getImplementation(originalMethod), method_getTypeEncoding(originalMethod))</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                method_exchangeImplementations(originalMethod, swizzledMethod)</div><div class="line">            &#125;</div><div class="line">        &#125;()</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">// MARK: - Method Swizzling</span></div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">proj_foo</span><span class="params">(<span class="number">_</span> bar: Bool)</span></span> &#123;</div><div class="line">        <span class="keyword">self</span>.proj_foo(bar)</div><div class="line">        </div><div class="line">        <span class="keyword">let</span> className = <span class="type">NSStringFromClass</span>(type(of: <span class="keyword">self</span>))</div><div class="line">        <span class="built_in">print</span>(<span class="string">"class: <span class="subst">\(className)</span>"</span>)</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> ramsey = <span class="type">Programmer</span>()</div><div class="line"><span class="keyword">let</span> wu = <span class="type">Doctor</span>()</div><div class="line">ramsey.foo(<span class="literal">true</span>)</div><div class="line"><span class="built_in">print</span>(<span class="string">"======="</span>)</div><div class="line">ramsey.proj_foo(<span class="literal">true</span>)</div><div class="line"><span class="built_in">print</span>(<span class="string">"======="</span>)</div><div class="line">wu.foo(<span class="literal">true</span>)</div><div class="line"><span class="comment">/* </span></div><div class="line">Person.foo</div><div class="line">Programmer.foo</div><div class="line">class: methodSwizzling.Programmer</div><div class="line">=======</div><div class="line">Person.foo</div><div class="line">Programmer.foo</div><div class="line">=======</div><div class="line">Person.foo</div><div class="line">Doctor.foo</div><div class="line">*/</div></pre></td></tr></table></figure>
<h3 id="遍历获取属性-成员变量-方法-协议名"><a href="#遍历获取属性-成员变量-方法-协议名" class="headerlink" title="遍历获取属性/成员变量/方法/协议名"></a>遍历获取属性/成员变量/方法/协议名</h3><p>Objective-C 的 Runtime 这个框架里还有很多方法，可以让你在运行时做很多事情，比如获取属性名、方法名。协议名。</p>
<ul>
<li><p><code>class_copyPropertyList(_ cls: Swift.AnyClass!, _ outCount: UnsafeMutablePointer&lt;UInt32&gt;!) -&gt; UnsafeMutablePointer&lt;objc_property_t?&gt;!</code></p>
</li>
<li><p><code>property_getName(_ property: objc_property_t!) -&gt; UnsafePointer&lt;Int8&gt;!</code></p>
</li>
<li><p><code>class_copyIvarList(_ cls: Swift.AnyClass!, _ outCount: UnsafeMutablePointer&lt;UInt32&gt;!) -&gt; UnsafeMutablePointer&lt;Ivar?&gt;!</code></p>
</li>
<li><p><code>ivar_getName(_ v: Ivar!) -&gt; UnsafePointer&lt;Int8&gt;!</code></p>
</li>
<li><p><code>class_copyMethodList(_ cls: Swift.AnyClass!, _ outCount: UnsafeMutablePointer&lt;UInt32&gt;!) -&gt; UnsafeMutablePointer&lt;Method?&gt;!</code></p>
</li>
<li><p><code>method_getName(_ m: Method!) -&gt; Selector!</code></p>
</li>
<li><p><code>sel_getName(_ sel: Selector!) -&gt; UnsafePointer&lt;Int8&gt;!</code></p>
</li>
<li><p><code>class_copyProtocolList(_ cls: Swift.AnyClass!, _ outCount: UnsafeMutablePointer&lt;UInt32&gt;!) -&gt; AutoreleasingUnsafeMutablePointer&lt;Protocol?&gt;!</code></p>
</li>
<li><p><code>protocol_getName(_ p: Protocol!) -&gt; UnsafePointer&lt;Int8&gt;!</code></p>
</li>
</ul>
<p>看下具体实现：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 记录成员变量/属性的个数</span></div><div class="line"><span class="keyword">var</span> <span class="built_in">count</span> : <span class="type">UInt32</span> = <span class="number">0</span></div><div class="line"><span class="comment">// 获取所有成员变量/属性、个数</span></div><div class="line"><span class="keyword">let</span> ivarList = class_copyIvarList(<span class="type">UIViewController</span>().classForCoder, &amp;<span class="built_in">count</span>)</div><div class="line"><span class="comment">// 遍历成员变量/属性获取成员变量名</span></div><div class="line"><span class="keyword">for</span> index <span class="keyword">in</span> <span class="number">0</span>...<span class="built_in">count</span>-<span class="number">1</span> &#123;</div><div class="line">	<span class="comment">// 获取成员变量/属性的C（C语言的字符串）</span></div><div class="line">	<span class="keyword">let</span> propertyNameC = ivar_getName(ivarList?[<span class="type">Int</span>(index)])</div><div class="line">	<span class="comment">// 将C语言字符串转成Swift语言的字符串</span></div><div class="line">	<span class="keyword">let</span> propertyName = <span class="type">String</span>(cString: propertyNameC!)</div><div class="line">	<span class="comment">// 获取成员变量/属性名的C（C语言的字符串）</span></div><div class="line">	<span class="keyword">let</span> propertyTypeC = ivar_getTypeEncoding(ivarList?[<span class="type">Int</span>(index)])</div><div class="line">	<span class="comment">// 将C语言字符串转成Swift语言的字符串</span></div><div class="line">	<span class="keyword">let</span> propertyType = <span class="type">String</span>(cString: propertyTypeC!)</div><div class="line">	<span class="built_in">print</span>(<span class="string">"propertyName: <span class="subst">\(propertyName)</span>, prorpertyType: <span class="subst">\(propertyType)</span>"</span>)</div><div class="line">&#125;</div><div class="line"><span class="comment">// 释放下内存，防止野指针</span></div><div class="line">free(ivarList)</div><div class="line"><span class="comment">/* 部分打印结果</span></div><div class="line">propertyName: _overrideTransitioningDelegate, prorpertyType: @"&lt;UIViewControllerTransitioningDelegate&gt;"</div><div class="line">propertyName: _view, prorpertyType: @"UIView"</div><div class="line">propertyName: _tabBarItem, prorpertyType: @"UITabBarItem"</div><div class="line">propertyName: _navigationItem, prorpertyType: @"UINavigationItem"</div><div class="line">propertyName: _toolbarItems, prorpertyType: @"NSArray"</div><div class="line">propertyName: _title, prorpertyType: @"NSString"</div><div class="line">propertyName: _nibName, prorpertyType: @"NSString"</div><div class="line">propertyName: _nibBundle, prorpertyType: @"NSBundle"</div><div class="line">propertyName: _parentViewController, prorpertyType: @"UIViewController"</div><div class="line">propertyName: _childModalViewController, prorpertyType: @"UIViewController"</div><div class="line">propertyName: _parentModalViewController, prorpertyType: @"UIViewController"</div><div class="line">propertyName: _previousRootViewController, prorpertyType: @"UIViewController"</div><div class="line">*/</div></pre></td></tr></table></figure>
<p>这里需要注意的是 <code>Swift</code> 的属性名和成员变量名是一样的，不会生成加有下划线的成员变量名，这点与 <code>Objective-C</code> 区别开。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 记录方法的个数</span></div><div class="line"><span class="keyword">var</span> <span class="built_in">count</span> : <span class="type">UInt32</span> = <span class="number">0</span></div><div class="line"><span class="comment">// 获取所有方法、个数</span></div><div class="line"><span class="keyword">let</span> method = class_copyMethodList(<span class="type">UIViewController</span>.classForCoder(), &amp;<span class="built_in">count</span>)</div><div class="line"><span class="comment">// 遍历方法获取方法名</span></div><div class="line"><span class="keyword">for</span> index <span class="keyword">in</span> <span class="number">0</span>...<span class="built_in">count</span>-<span class="number">1</span> &#123;</div><div class="line">    <span class="comment">// 获取方法</span></div><div class="line">    <span class="keyword">let</span> sel = method_getName(method?[<span class="type">Int</span>(index)])</div><div class="line">    <span class="comment">// 获取方法名的C（C语言的字符串）</span></div><div class="line">    <span class="keyword">let</span> methodNameC = sel_getName(sel)</div><div class="line">    <span class="comment">// 将C语言字符串转成Swift语言的字符串</span></div><div class="line">    <span class="keyword">let</span> methodName = <span class="type">String</span>(cString: methodNameC!)</div><div class="line">    <span class="built_in">print</span>(<span class="string">"methodName: <span class="subst">\(methodName)</span>"</span>)</div><div class="line">&#125;</div><div class="line"><span class="comment">// 释放下内存，防止野指针</span></div><div class="line">free(method)</div><div class="line"><span class="comment">/* 部分打印</span></div><div class="line">methodName: title</div><div class="line">methodName: setTitle:</div><div class="line">methodName: invalidate</div><div class="line">methodName: setValue:forKey:</div><div class="line">methodName: encodeWithCoder:</div><div class="line">methodName: initWithCoder:</div><div class="line">methodName: init</div><div class="line">methodName: view</div><div class="line">methodName: _description</div><div class="line">*/</div></pre></td></tr></table></figure>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 记录协议的个数</span></div><div class="line"><span class="keyword">var</span> <span class="built_in">count</span> : <span class="type">UInt32</span> = <span class="number">0</span></div><div class="line"><span class="comment">// 获取所有协议、个数</span></div><div class="line"><span class="keyword">let</span> protocols = class_copyProtocolList(<span class="type">UIViewController</span>.classForCoder(), &amp;<span class="built_in">count</span>)</div><div class="line"><span class="comment">// 遍历协议获取协议名</span></div><div class="line"><span class="keyword">for</span> index <span class="keyword">in</span> <span class="number">0</span>...<span class="built_in">count</span>-<span class="number">1</span> &#123;</div><div class="line">    <span class="comment">// 获取协议名的C（C语言的字符串）</span></div><div class="line">    <span class="keyword">let</span> protocolNameC = protocol_getName(protocols?[<span class="type">Int</span>(index)])</div><div class="line">    <span class="comment">// 将C语言字符串转成Swift语言的字符串</span></div><div class="line">    <span class="keyword">let</span> protocolName = <span class="type">String</span>(cString: protocolNameC!)</div><div class="line">    <span class="built_in">print</span>(<span class="string">"protocolName: <span class="subst">\(protocolName)</span>"</span>)</div><div class="line">&#125;</div><div class="line"><span class="comment">/*</span></div><div class="line">protocolName: _UIViewServiceDeputy</div><div class="line">protocolName: NSExtensionRequestHandling</div><div class="line">protocolName: UIViewControllerPresenting</div><div class="line">protocolName: _UITraitEnvironmentInternal</div><div class="line">protocolName: _UIContentContainerInternal</div><div class="line">protocolName: _UIFocusEnvironmentInternal</div><div class="line">protocolName: NSCoding</div><div class="line">protocolName: UIAppearanceContainer</div><div class="line">protocolName: UITraitEnvironment</div><div class="line">protocolName: UIContentContainer</div><div class="line">protocolName: UIFocusEnvironment</div><div class="line">*/</div></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这篇文章主要总结了下 Swift 中 Runtime 是如何使用的，在此做一个记录，方便自己复习。</p>
<p>同事这篇文章并没有过多的解读 Runtime 背后的原理，日后有时间，讲在写一篇原理篇。</p>
<h2 id="推荐"><a href="#推荐" class="headerlink" title="推荐"></a>推荐</h2><p>原理篇可以先看下下面三篇文章：</p>
<p><a href="http://www.jianshu.com/p/db6dc23834e3#" target="_blank" rel="external">神经病院Objective-C Runtime出院第三天——如何正确使用Runtime</a></p>
<p><a href="http://yulingtianxia.com/blog/2014/11/05/objective-c-runtime/" target="_blank" rel="external">Objective-C Runtime</a></p>
<p><a href="http://www.swiftcafe.io/2016/01/16/objc-runtime/" target="_blank" rel="external">Objective-C Runtime 消息机制 - 代码背后发生的事情</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;使用 Obejective-C 开发 iOS 程序的同学一定对 Runtime 运行时机制不陌生，由于 Obejective-C 是一门动态语言，它会将一些工作从编译时推迟到运行时。实际上，由于 Objective-C 的消息分发机制，所有使用 Objective-C 编写的函数或方法，本质上都是通过 Objective-C Runtime 的 &lt;code&gt;objc_msgSend&lt;/code&gt; 函数发送的一个消息传递。于是，我们可以通过 Objective-C Runtime 机制的特点，来动态的改变函数的实现，实现 Method Swizzling，亦或是通过 category 来给类扩展存储属性。&lt;/p&gt;
    
    </summary>
    
      <category term="编程" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="iOS" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B/iOS/"/>
    
      <category term="Swift" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B/iOS/Swift/"/>
    
    
      <category term="编程" scheme="http://yoursite.com/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="iOS" scheme="http://yoursite.com/tags/iOS/"/>
    
      <category term="Swift" scheme="http://yoursite.com/tags/Swift/"/>
    
      <category term="Runtime" scheme="http://yoursite.com/tags/Runtime/"/>
    
  </entry>
  
  <entry>
    <title>iOS中的内存管理(ARC)-Swift</title>
    <link href="http://yoursite.com/2017/01/04/ARC-in-Swift/"/>
    <id>http://yoursite.com/2017/01/04/ARC-in-Swift/</id>
    <published>2017-01-04T02:24:42.000Z</published>
    <updated>2017-01-06T00:55:43.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><code>Swift</code> 使用 <code>ARC(Automatic Reference Counting)</code> 这一机制来跟踪和管理程序的内存使用状况。通常情况我们并不需要去考虑内存的管理，<code>ARC</code> 机制会一直起作用，确保类的实例不再被使用时，可以自动释放其所占的内存。</p>
<blockquote>
<p><code>ARC</code> 只会对引用类型起作用，结构体(Struct)和枚举类型(enum)是值类型，不是引用类型，也不是通过引用的方式存储和传递。</p>
</blockquote>
<p>然而在少数情况下，<code>ARC</code> 需要我们提供更多的代码之间的信息来更好的管理内存，这篇文章则主要关注这些少数情况。</p>
<a id="more"></a>
<h2 id="ARC-的工作机制"><a href="#ARC-的工作机制" class="headerlink" title="ARC 的工作机制"></a>ARC 的工作机制</h2><p>当我们每次创建一个类的新的实例的时候，ARC 会分配一大块内存用来储存实例的信息。内存中会包含实例的类型信息，以及这个实例所有相关属性的值。此外，当实例不再被使用时，ARC 释放实例所占用的内存，并让释放的内存能挪作他用。这确保了不再被使用的实例，不会一直占用内存空间。</p>
<p>如果我们尝试访问一个已经被销毁的类的实例，则会引起程序的崩溃，为了确保使用中的实例不会被销毁，ARC 会跟踪和计算每一个实例正在被多少属性，常量和变量所引用。哪怕实例的引用数为一，ARC都不会销毁这个实例。</p>
<p>为了使之成为可能，无论你将实例赋值给属性，常量或者是变量，属性，常量或者变量，都会对此实例创建强引用。之所以称之为<strong>强引用</strong>，是因为它会将实例牢牢的保持住，只要强引用还在，实例是不允许被销毁的。</p>
<p><strong>然而在某些情况下，一个类永远不会有0个强引用，这种情况是由于循环强引用所导致的，此时则会造成内存泄露，而解决循环强引用的办法是引入<code>weak</code> 或 <code>unowned</code> 关键字</strong>。</p>
<p>会引起循环强引用的情况主要有两种，<strong>类实例之间的循环强引用</strong>和<strong>闭包引起的循环强引用。</strong></p>
<h2 id="类实例之间的循环强引用及解决方法"><a href="#类实例之间的循环强引用及解决方法" class="headerlink" title="类实例之间的循环强引用及解决方法"></a>类实例之间的循环强引用及解决方法</h2><h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p>首先我们给出三种情况下类实例之间的循环强引用的解决办法。</p>
<ol>
<li><p>两个类的属性的值都允许为 <code>nil</code>，并会潜在的产生循环强引用，使用弱引用 <code>weak</code> 来解决。</p>
</li>
<li><p>两个类的属性的值，一个允许为 <code>nil</code>，另一个不允许为 <code>nil</code>，并会潜在的产生循环强引用，使用无主引用 <code>unowned</code> 来解决。</p>
</li>
<li><p>两个类的属性都不允许为 <code>nil</code>，并会潜在的产生循环强引用，一个类使用无主引用 <code>unowned</code>，另一个使用隐式解析可选属性 (<code>Implicitly Unwrapped Optionals</code>)。</p>
</li>
</ol>
<blockquote>
<p>对于生命周期中会变为 <code>nil</code> 的实例使用弱引用。相反的，对于初始化赋值后再也不会被赋值为 <code>nil</code> 的实例，使用无主引用。</p>
<p><strong>注意：<br>弱引用必须被声明为变量，表明其值能在运行时被修改。弱引用不能被声明为常量。</strong></p>
</blockquote>
<h3 id="弱引用-weak-reference"><a href="#弱引用-weak-reference" class="headerlink" title="弱引用 (weak reference)"></a>弱引用 (weak reference)</h3><p>在下面这个例子中，展示了一个不经意间造成的循环强引用。例子定义了两个类：<code>Person</code> 和 <code>Apartment</code>，用来建模公寓和其中的居民：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;   </div><div class="line">	<span class="keyword">let</span> name: <span class="type">String</span></div><div class="line">	<span class="keyword">init</span>(name: <span class="type">String</span>) &#123; <span class="keyword">self</span>.name = name &#125;</div><div class="line">	<span class="keyword">var</span> apartment: <span class="type">Apartment</span>?</div><div class="line">	<span class="keyword">deinit</span> &#123; <span class="built_in">print</span>(<span class="string">"<span class="subst">\(name)</span> is being deinitialized"</span>) &#125;	</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Apartment</span> </span>&#123;</div><div class="line">    <span class="keyword">let</span> number: <span class="type">Int</span></div><div class="line">    <span class="keyword">init</span>(number: <span class="type">Int</span>) &#123; <span class="keyword">self</span>.number = number &#125;</div><div class="line">    <span class="keyword">var</span> tenant: <span class="type">Person</span>?</div><div class="line">    <span class="keyword">deinit</span> &#123; <span class="built_in">print</span>(<span class="string">"Apartment #<span class="subst">\(number)</span> is being deinitialized"</span>) &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>每一个<code>Person</code>实例有一个类型为<code>String</code>，名字为<code>name</code>的属性，并有一个可选的初始化为<code>nil</code>的<code>apartment</code>属性。<code>apartment</code>属性是可选的，因为一个人并不总是拥有公寓。</p>
<p>类似的，每个<code>Apartment</code>实例有一个叫<code>number</code>，类型为<code>Int</code>的属性，并有一个可选的初始化为<code>nil</code>的<code>tenant</code>属性。<code>tenant</code>属性是可选的，因为一栋公寓并不总是有居民。</p>
<p>接下来的代码片段定义了两个可选类型的变量<code>john</code>和<code>number73</code>,并分别被设定为下面的<code>Apartment</code>和<code>Person</code>的实例。这两个变量都被初始化为<code>nil</code>，并为可选的：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> john: <span class="type">Person</span>?</div><div class="line"><span class="keyword">var</span> number73: <span class="type">Apartment</span>?</div></pre></td></tr></table></figure>
<p>现在你可以创建特定的<code>Person</code>和<code>Apartment</code>实例并将类实例赋值给<code>john</code>和<code>number73</code>变量：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">john = <span class="type">Person</span>(name: <span class="string">"John Appleseed"</span>)</div><div class="line">number73 = <span class="type">Apartment</span>(number: <span class="number">73</span>)</div></pre></td></tr></table></figure>
<p>当两个实例被创建并且赋值后，下图表示了当前的强引用关系。变量<code>john</code>现在有一个指向<code>Person</code>实例的强引用，而变量<code>number73</code>有一个指向<code>Apartment</code>实例的强引用：</p>
<p><img src="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Art/referenceCycle01_2x.png" alt=""></p>
<p>现在我们将两个变量进行关联，这样人就能有公寓住了，并且公寓里也有房客了。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">john!.apartment = number73</div><div class="line">number73!.tenant = john</div></pre></td></tr></table></figure>
<p>两个变量关联之后，强引用关系如图：</p>
<p><img src="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Art/referenceCycle02_2x.png" alt=""></p>
<p>很不幸的是，此时一个循环强引用已经建立了，如果此时我们将两个变量 <code>john</code> 和 <code>number73</code> 至为 <code>nil</code> 时，引用计数并不会变为0，实例不会被 ARC 销毁，没有任何一个析构函数会被调用，循环强引用阻止了 <code>Person</code> 和 <code>Apartment</code> 类实例的销毁，造成内存泄漏。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">john = <span class="literal">nil</span></div><div class="line">number73 = <span class="literal">nil</span></div></pre></td></tr></table></figure>
<p>在将 <code>john</code> 和 <code>number73</code> 赋值为 <code>nil</code> 后，强引用关系如下图：</p>
<p><img src="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Art/referenceCycle03_2x.png" alt=""></p>
<p>根据结论部分第一条原则，当两个类的属性都可以为 <code>nil</code> 的时候，我们使用 <code>weak</code> 来解决循环强引用。</p>
<p>同样的，也可以根据 </p>
<blockquote>
<p>在实例的生命周期中，如果某些时候引用没有值，那么弱引用可以阻止循环强引用。如果引用总是有值，则可以使用无主引用。</p>
</blockquote>
<p>这条原则来判断。</p>
<p>在上面 <code>Apartment</code> 的例子中，一个公寓的生命周期中，有时是没有“居民”的，因此适合使用弱引用来解决循环强引用。</p>
<p>下面的例子跟上面 <code>Person</code> 和 <code>Apartment</code> 的例子一致，但是有一个重要的区别。这一次，<code>Apartment</code>的 <code>tenant</code> 属性被声明为弱引用：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</div><div class="line">    <span class="keyword">let</span> name: <span class="type">String</span></div><div class="line">    <span class="keyword">init</span>(name: <span class="type">String</span>) &#123; <span class="keyword">self</span>.name = name &#125;</div><div class="line">    <span class="keyword">var</span> apartment: <span class="type">Apartment</span>?</div><div class="line">    <span class="keyword">deinit</span> &#123; <span class="built_in">print</span>(<span class="string">"<span class="subst">\(name)</span> is being deinitialized"</span>) &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Apartment</span> </span>&#123;</div><div class="line">    <span class="keyword">let</span> number: <span class="type">Int</span></div><div class="line">    <span class="keyword">init</span>(number: <span class="type">Int</span>) &#123; <span class="keyword">self</span>.number = number &#125;</div><div class="line">    <span class="keyword">weak</span> <span class="keyword">var</span> tenant: <span class="type">Person</span>?</div><div class="line">    <span class="keyword">deinit</span> &#123; <span class="built_in">print</span>(<span class="string">"Apartment #<span class="subst">\(number)</span> is being deinitialized"</span>) &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>然后跟之前一样，建立两个变量（john和number73）之间的强引用，并关联两个实例：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> john: <span class="type">Person</span>?</div><div class="line"><span class="keyword">var</span> number73: <span class="type">Apartment</span>?</div><div class="line"></div><div class="line">john = <span class="type">Person</span>(name: <span class="string">"John Appleseed"</span>)</div><div class="line">number73 = <span class="type">Apartment</span>(number: <span class="number">73</span>)</div><div class="line"></div><div class="line">john!.apartment = number73</div><div class="line">number73!.tenant = john</div></pre></td></tr></table></figure>
<p>现在，两个关联在一起的实例的引用关系如下图所示：</p>
<p><img src="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Art/weakReference01_2x.png" alt=""></p>
<p><code>Person</code> 实例依然保持对 <code>Apartment</code> 实例的强引用，但是 <code>Apartment</code> 实例只是对 <code>Person</code> 实例的弱引用。这意味着当你断开 <code>john</code> 变量所保持的强引用时，再也没有指向 <code>Person</code> 实例的强引用了：</p>
<p><img src="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Art/weakReference02_2x.png" alt=""></p>
<p>由于再也没有指向 <code>Person</code> 实例的强引用，该实例会被销毁：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">john = <span class="literal">nil</span></div><div class="line"><span class="comment">// prints "John Appleseed is being deinitialized"</span></div></pre></td></tr></table></figure>
<p>唯一剩下的指向 <code>Apartment</code> 实例的强引用来自于变量 <code>number73</code>。如果你断开这个强引用，再也没有指向 <code>Apartment</code> 实例的强引用了：</p>
<p><img src="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Art/weakReference03_2x.png" alt=""></p>
<p>由于再也没有指向 <code>Apartment</code> 实例的强引用，该实例也会被销毁：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">number73 = <span class="literal">nil</span></div><div class="line"><span class="comment">// prints "Apartment #73 is being deinitialized"</span></div></pre></td></tr></table></figure>
<p>上面的两段代码展示了变量 <code>john</code> 和 <code>number73</code> 在被赋值为 <code>nil</code> 后，<code>Person</code> 实例和 <code>Apartment</code> 实例的析构函数都打印出“销毁”的信息。这证明了引用循环被打破了。</p>
<h3 id="无主引用-unowned-reference"><a href="#无主引用-unowned-reference" class="headerlink" title="无主引用 (unowned reference)"></a>无主引用 (unowned reference)</h3><p>和弱引用类似，无主引用不会牢牢保持住引用的实例。和弱引用不同的是，无主引用是<strong>永远有值的</strong>。因此，无主引用总是被定义为非可选类型（non-optional type）。你可以在声明属性或者变量时，在前面加上关键字 <code>unowned</code> 表示这是一个无主引用。</p>
<p>由于无主引用是非可选类型，你不需要在使用它的时候将它展开。无主引用总是可以被直接访问。不过 ARC <strong>无法在实例被销毁后将无主引用设为 <code>nil</code></strong>，因为非可选类型的变量不允许被赋值为 <code>nil</code>。</p>
<blockquote>
<p> 注意:<br>如果你试图在实例被销毁后，访问该实例的无主引用，会触发运行时错误。使用无主引用，你必须确保引用始终指向一个未销毁的实例。<br>还需要注意的是如果你试图访问实例已经被销毁的无主引用，程序会直接崩溃，而不会发生无法预期的行为。所以你应当避免这样的事情发生。</p>
</blockquote>
<p>下面的例子定义了两个类，<code>Customer</code> 和 <code>CreditCard</code>，模拟了银行客户和客户的信用卡。这两个类中，每一个都将另外一个类的实例作为自身的属性。这种关系会潜在的创造循环强引用。</p>
<p><code>Customer</code> 和 <code>CreditCard</code> 之间的关系与前面弱引用例子中 <code>Apartment</code> 和 <code>Person</code> 的关系截然不同。在这个数据模型中，一个客户可能有或者没有信用卡，但是一张信用卡总是关联着一个客户。为了表示这种关系，<code>Customer</code> 类有一个可选类型的 <code>card</code> 属性，但是 <code>CreditCard</code> 类有一个非可选类型的 <code>customer</code> 属性。</p>
<p>此外，只能通过将一个 <code>number</code> 值和 <code>customer</code> 实例传递给 <code>CreditCard</code> 构造函数的方式来创建 <code>CreditCard</code> 实例。这样可以确保当创建 <code>CreditCard</code> 实例时总是有一个 <code>customer</code> 实例与之关联。</p>
<p>由于信用卡总是关联着一个客户，根据结论中的第二条原则，当两个类的属性的值，一个允许为 <code>nil</code>，另一个不允许为 <code>nil</code> 时，使用无主引用来避免循环强引用， 因此在这里将 <code>customer</code> 属性定义为无主引用，用以避免循环强引用：</p>
<blockquote>
<p>两个实例A和B，如果实例A必须在实例B存在的前提下才能存在，那么实例A必须用 <code>unowned</code> 无主引用指向实例B。也就是说，有强制依赖性的那个实例必须对另一个实例持有无主引用。</p>
</blockquote>
<p>根据上面这句话，我们可以确定在此种情况下，哪一个类的属性被设置为无主引用。</p>
<p>实例 (A) <code>CreditCard</code> 必须在 实例 (B)  <code>Customer</code> 存在的前提下才能存在（信用卡必须被客户持有），那么实例 (A)   <code>CreditCard</code> 必须用 <code>unowned</code> 无主引用指向实例 (B)  <code>Customer</code>。也就是说这里实例 <code>CreditCard</code> 有强依赖性，它必须对另一个实例 <code>Customer</code> 持有无主引用。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Customer</span> </span>&#123;</div><div class="line">    <span class="keyword">let</span> name: <span class="type">String</span></div><div class="line">    <span class="keyword">var</span> card: <span class="type">CreditCard</span>?</div><div class="line">    <span class="keyword">init</span>(name: <span class="type">String</span>) &#123;</div><div class="line">        <span class="keyword">self</span>.name = name</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">deinit</span> &#123; <span class="built_in">print</span>(<span class="string">"<span class="subst">\(name)</span> is being deinitialized"</span>) &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">CreditCard</span> </span>&#123;</div><div class="line">    <span class="keyword">let</span> number: <span class="type">Int</span></div><div class="line">    <span class="keyword">unowned</span> <span class="keyword">let</span> customer: <span class="type">Customer</span></div><div class="line">    <span class="keyword">init</span>(number: <span class="type">Int</span>, customer: <span class="type">Customer</span>) &#123;</div><div class="line">        <span class="keyword">self</span>.number = number</div><div class="line">        <span class="keyword">self</span>.customer = customer</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">deinit</span> &#123; <span class="built_in">print</span>(<span class="string">"Card #<span class="subst">\(number)</span> is being deinitialized"</span>) &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>下面的代码片段定义了一个叫 <code>john</code> 的可选类型 <code>Customer</code> 变量，用来保存某个特定客户的引用。由于是可选类型，所以变量被初始化为 <code>nil</code>。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> john: <span class="type">Customer</span>?</div></pre></td></tr></table></figure>
<p>现在我们可以创建 <code>Customer</code> 类的实例，用它初始化 <code>CreditCard</code> 实例，并将新创建的 <code>CreditCard</code> 实例赋值为客户的 <code>card</code> 属性。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">john = <span class="type">Customer</span>(name: <span class="string">"John Appleseed"</span>)</div><div class="line">john!.card = <span class="type">CreditCard</span>(number: <span class="number">1234_5678_9012_3456</span>, customer: john!)</div></pre></td></tr></table></figure>
<p>当我们关联两个实例后，它们的引用关系如下图所示：</p>
<p><img src="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Art/unownedReference01_2x.png" alt=""></p>
<p><code>Customer</code> 实例持有对 <code>CreditCard</code> 实例的强引用，而 <code>CreditCard</code> 实例持有对 <code>Customer</code> 实例的无主引用。</p>
<p>由于 <code>customer</code> 的无主引用，当你断开 <code>john</code> 变量持有的强引用时，再也没有指向 <code>Customer</code> 实例的强引用了：</p>
<p><img src="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Art/unownedReference02_2x.png" alt=""></p>
<p>由于再也没有指向 <code>Customer</code> 实例的强引用，该实例被销毁了。其后，再也没有指向 <code>CreditCard</code> 实例的强引用，该实例也随之被销毁了：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">john = <span class="literal">nil</span></div><div class="line"><span class="comment">// prints "John Appleseed is being deinitialized"</span></div><div class="line"><span class="comment">// prints "Card #1234567890123456 is being deinitialized"</span></div></pre></td></tr></table></figure>
<h3 id="无主引用以及隐式解析可选属性"><a href="#无主引用以及隐式解析可选属性" class="headerlink" title="无主引用以及隐式解析可选属性"></a>无主引用以及隐式解析可选属性</h3><p>除了以上两种情况，还有可能出现第三种情况，两个属性都必须有值，并且初始化完成后不能为 <code>nil</code> 。在这种场景下，需要一个类使用无主属性，另一个类使用隐式解析可选属性。</p>
<p>这使两个属性在初始化完成后能被直接访问（不需要可选展开），同时避免了循环引用。</p>
<p>下面这个例子说明了如何建立这种关系。</p>
<p>下面的例子定义了两个类，<code>Country</code> 和 <code>City</code>，每个类将另外一个类的实例保存为属性。在这个模型中，每个国家必须有首都，而每一个城市必须属于一个国家。为了实现这种关系，<code>Country</code> 类拥有一个 <code>capitalCity</code> 属性，而 <code>City</code> 类有一个 <code>country</code> 属性：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Country</span> </span>&#123;</div><div class="line">    <span class="keyword">let</span> name: <span class="type">String</span></div><div class="line">    <span class="keyword">let</span> capitalCity: <span class="type">City</span>!</div><div class="line">    <span class="keyword">init</span>(name: <span class="type">String</span>, capitalName: <span class="type">String</span>) &#123;</div><div class="line">        <span class="keyword">self</span>.name = name</div><div class="line">        <span class="keyword">self</span>.capitalCity = <span class="type">City</span>(name: capitalName, country: <span class="keyword">self</span>)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">City</span> </span>&#123;</div><div class="line">    <span class="keyword">let</span> name: <span class="type">String</span></div><div class="line">    <span class="keyword">unowned</span> <span class="keyword">let</span> country: <span class="type">Country</span></div><div class="line">    <span class="keyword">init</span>(name: <span class="type">String</span>, country: <span class="type">Country</span>) &#123;</div><div class="line">        <span class="keyword">self</span>.name = name</div><div class="line">        <span class="keyword">self</span>.country = country</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>为了建立两个类的依赖关系，<code>City</code> 的构造函数有一个 <code>Country</code> 实例的参数，并且将实例保存为 <code>country</code> 属性。</p>
<p><code>Country</code>的构造函数调用了 <code>City</code> 的构造函数。然而，只有 <code>Country</code> 的实例完全初始化完后，<code>Country</code> 的构造函数才能把 <code>self</code> 传给 <code>City</code> 的构造函数。</p>
<p>为了满足这种需求，通过在类型结尾处加上感叹号（City!）的方式，将 <code>Country</code> 的 <code>capitalCity</code> 属性声明为隐式解析可选类型的属性。这表示像其他可选类型一样，<code>capitalCity</code> 属性的默认值为 <code>nil</code>，但是不需要展开它的值就能访问它。</p>
<p>由于 <code>capitalCity</code> 默认值为 <code>nil</code>，一旦 <code>Country</code> 的实例在构造函数中给 <code>name</code> 属性赋值后，整个初始化过程就完成了。这代表一旦 <code>name</code> 属性被赋值后，<code>Country</code> 的构造函数就能引用并传递隐式的 <code>self</code>。<code>Country</code> 的构造函数在赋值 <code>capitalCity</code> 时，就能将 <code>self</code> 作为参数传递给 <code>City</code> 的构造函数。</p>
<p>以上的意义在于你可以通过一条语句同时创建 <code>Country</code> 和 <code>City</code> 的实例，而不产生循环强引用，并且 <code>capitalCity</code> 的属性能被直接访问，而不需要通过感叹号来展开它的可选值：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> country = <span class="type">Country</span>(name: <span class="string">"China"</span>, capitalName: <span class="string">"BeiJing"</span>)</div><div class="line"><span class="built_in">print</span>(<span class="string">"<span class="subst">\(country.name)</span>'s capital city is called <span class="subst">\(country.capitalCity.name)</span>"</span>)</div><div class="line"><span class="comment">// prints "China's capital city is called BieJing"</span></div></pre></td></tr></table></figure>
<p>在上面的例子中，使用隐式解析可选值的意义在于满足了两个类构造函数的需求。<code>capitalCity</code> 属性在初始化完成后，能像非可选值一样使用和存取同时还避免了循环强引用。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>为了段落的首位呼应，再次总结下：</p>
<ul>
<li><p><code>Person</code> 和 <code>Apartment</code> 的例子展示了两个属性的值都允许为 <code>nil</code>，并会潜在的产生循环强引用。这种场景最适合用弱引用来解决。</p>
</li>
<li><p><code>Customer</code> 和 <code>CreditCard</code> 的例子展示了一个属性的值允许为 <code>nil</code>，而另一个属性的值不允许为 <code>nil</code>，并会潜在的产生循环强引用。这种场景最适合通过无主引用来解决。</p>
</li>
<li><p><code>Country</code> 和 <code>City</code> 的例子展示了两个属性的值都不允许为 <code>nil</code>，并会潜在的产生循环强引用。这种场景需要一个类使用无主属性，而另外一个类使用隐式解析可选属性。</p>
</li>
</ul>
<h2 id="闭包引起的循环强引用及解决方法"><a href="#闭包引起的循环强引用及解决方法" class="headerlink" title="闭包引起的循环强引用及解决方法"></a>闭包引起的循环强引用及解决方法</h2><h3 id="如何产生？"><a href="#如何产生？" class="headerlink" title="如何产生？"></a>如何产生？</h3><p>除了实例之间的循环强引用，还有一种情况会引起循环强引用，那就是<strong>闭包</strong>。</p>
<p>当你将一个闭包赋值给类实例的某个属性，并且这个闭包体中又使用了实例。这个闭包体中可能访问了实例的某个属性，例如 <code>self.someProperty</code>，或者闭包中调用了实例的某个方法，例如 <code>self.someMethod</code>。这两种情况都导致了闭包 “捕获”  <code>self</code>，从而产生了循环强引用。</p>
<p>循环强引用的产生，是因为闭包和类相似，都是<strong>引用类型</strong>。当你把一个闭包赋值给某个属性时，你也把一个引用赋值给了这个闭包。实质上，这跟之前的问题是一样的－两个强引用让彼此一直有效。但是，和两个类实例不同，这次一个是类实例，另一个是闭包。</p>
<p>Swift 提供了一种优雅的方法来解决这个问题，称之为<strong>闭包占用列表</strong>（closuer capture list）。同样的，在学习如何用闭包占用列表破坏循环强引用之前，先来了解一下循环强引用是如何产生的，这对我们是很有帮助的。</p>
<p>下面的例子为你展示了当一个闭包引用了 <code>self</code> 后是如何产生一个循环强引用的。例子中定义了一个叫 <code>HTMLElement</code> 的类，用一种简单的模型表示 HTML 中的一个单独的元素：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">HTMLElement</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">let</span> name: <span class="type">String</span></div><div class="line">    <span class="keyword">let</span> text: <span class="type">String</span>?</div><div class="line"></div><div class="line">    <span class="comment">// asHTML 是一个参数为空，返回一个String类型值的闭包类型</span></div><div class="line">    <span class="comment">// 这里相当于类HTMLElement的一个属性asHTML引用了一个闭包</span></div><div class="line">    <span class="comment">// 但闭包中引用了self，因此闭包捕获了self，这意味着闭包反过来又持有了HTMLElement实例的强引用，这样就造成了循环强引用。</span></div><div class="line">    <span class="built_in">lazy</span> <span class="keyword">var</span> asHTML: () -&gt; <span class="type">String</span> = &#123;	</div><div class="line">        <span class="keyword">if</span> <span class="keyword">let</span> text = <span class="keyword">self</span>.text &#123;</div><div class="line">            <span class="keyword">return</span> <span class="string">"&lt;<span class="subst">\(<span class="keyword">self</span>.name)</span>&gt;<span class="subst">\(text)</span>&lt;/<span class="subst">\(<span class="keyword">self</span>.name)</span>&gt;"</span></div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">return</span> <span class="string">"&lt;<span class="subst">\(<span class="keyword">self</span>.name)</span> /&gt;"</span></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">init</span>(name: <span class="type">String</span>, text: <span class="type">String</span>? = <span class="literal">nil</span>) &#123;</div><div class="line">        <span class="keyword">self</span>.name = name</div><div class="line">        <span class="keyword">self</span>.text = text</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">deinit</span> &#123;</div><div class="line">        <span class="built_in">print</span><span class="string">"<span class="subst">\(name)</span> is being deinitialized"</span>)</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>首先来解释下这个类。</p>
<p><code>HTMLElement</code> 类定义了一个 <code>name</code> 属性来表示这个元素的名称，例如代表段落的”p”，或者代表换行的”br”。<code>HTMLElement</code> 还定义了一个可选属性 <code>text</code>，用来设置和展现 HTML 元素的文本。</p>
<p>除了上面的两个属性，<code>HTMLElement</code> 还定义了一个 <code>lazy</code> 属性 <code>asHTML</code>。这个属性引用了一个闭包，将 <code>name</code> 和 <code>text</code> 组合成 HTML 字符串片段。该属性是 <code>() -&gt; String</code> 类型，或者可以理解为“一个没有参数，返回 <code>String</code> 的函数”。</p>
<p>默认情况下，闭包赋值给了 <code>asHTML</code> 属性，这个闭包返回一个代表 HTML 标签的字符串。如果 <code>text</code> 值存在，该标签就包含可选值 <code>text</code>；如果 <code>text</code> 不存在，该标签就不包含文本。对于段落元素，根据 <code>text</code> 是 <code>&quot;some text&quot;</code> 还是 <code>nil</code> ，闭包会返回 <code>&quot;&lt;p&gt;some text&lt;/p&gt;&quot;</code> 或者 <code>&quot;&lt;p /&gt;&quot;</code>。</p>
<p>可以像实例方法那样去命名、使用 <code>asHTML</code> 属性。然而，由于 <code>asHTML</code> 是闭包而不是实例方法，如果你想改变特定元素的 HTML 处理的话，可以用自定义的闭包来取代默认值。</p>
<blockquote>
<p>注意:<br><code>asHTML</code> 声明为 <code>lazy</code> 属性，因为只有当元素确实需要处理为HTML输出的字符串时，才需要使用 <code>asHTML</code>。也就是说，在默认的闭包中可以使用 <code>self</code>，因为只有当初始化完成以及 <code>self</code> 确实存在后，才能访问 <code>lazy</code> 属性。</p>
</blockquote>
<p><code>HTMLElement</code> 类只提供一个构造函数，通过 <code>name</code> 和 <code>text</code>（如果有的话）参数来初始化一个元素。该类也定义了一个析构函数，当 <code>HTMLElement</code> 实例被销毁时，打印一条消息。</p>
<p>下面的代码展示了如何用 <code>HTMLElement</code> 类创建实例并打印消息。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> paragraph: <span class="type">HTMLElement</span>? = <span class="type">HTMLElement</span>(name: <span class="string">"p"</span>, text: <span class="string">"hello, world"</span>)</div><div class="line"><span class="built_in">print</span>(paragraph!.asHTML())</div><div class="line"><span class="comment">// prints"hello, world"</span></div></pre></td></tr></table></figure>
<blockquote>
<p>注意:<br>上面的 <code>paragraph</code> 变量定义为可选 <code>HTMLElement</code>，因此我们可以赋值 <code>nil</code> 给它来演示循环强引用。</p>
</blockquote>
<p>不幸的是，上面写的 <code>HTMLElement</code> 类产生了类实例和 <code>asHTML</code> 默认值的闭包之间的循环强引用。循环强引用如下图所示：</p>
<p><img src="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Art/closureReferenceCycle01_2x.png" alt=""></p>
<p>实例的 <code>asHTML</code> 属性持有闭包的强引用。但是，闭包在其闭包体内使用了 <code>self</code>（引用了 <code>self.name</code> 和 <code>self.text</code> ），因此闭包捕获了 <code>self</code>，这意味着闭包又反过来持有了 <code>HTMLElement</code> 实例的强引用。这样两个对象就产生了循环强引用。</p>
<blockquote>
<p>注意:<br>虽然闭包多次使用了 <code>self</code>，它只捕获 <code>HTMLElement</code> 实例的一个强引用。<br>如果设置 <code>paragraph</code> 变量为 <code>nil</code>，打破它持有的 <code>HTMLElement</code> 实例的强引用，<code>HTMLElement</code> 实例和它的闭包都不会被销毁，也是因为循环强引用：</p>
</blockquote>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">paragraph = <span class="literal">nil</span></div></pre></td></tr></table></figure>
<p>注意 <code>HTMLElementdeinitializer</code> 中的消息并没有被打印，证明了 <code>HTMLElement</code> 实例并没有被销毁。</p>
<h3 id="通过定义-捕获列表的方法-，可以避免闭包的循环强引用。"><a href="#通过定义-捕获列表的方法-，可以避免闭包的循环强引用。" class="headerlink" title="通过定义 捕获列表的方法 ，可以避免闭包的循环强引用。"></a>通过定义 <strong><em>捕获列表的方法</em></strong> ，可以避免闭包的循环强引用。</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 定义捕获列表，捕获列表放置在闭包参数列表和返回类型之前：</span></div><div class="line"><span class="built_in">lazy</span> <span class="keyword">var</span> someClosure: (<span class="type">Int</span>, <span class="type">String</span>) -&gt; <span class="type">String</span> = &#123;</div><div class="line">    [<span class="keyword">unowned</span> <span class="keyword">self</span>] (index: <span class="type">Int</span>, stringToProcess: <span class="type">String</span>) -&gt; <span class="type">String</span> <span class="keyword">in</span></div><div class="line">    <span class="comment">// closure body goes here</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 如果闭包没有指定参数列表或者返回类型，则可以通过上下文推断，那么可以捕获列表放在闭包开始的地方，跟着是关键字in：</span></div><div class="line"><span class="built_in">lazy</span> <span class="keyword">var</span> someClosure: () -&gt; <span class="type">String</span> = &#123;</div><div class="line">    [<span class="keyword">unowned</span> <span class="keyword">self</span>] <span class="keyword">in</span></div><div class="line">    <span class="comment">// closure body goes here</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>同样的，可以根据下面两条原则来确认使用 <code>weak</code> 还是 <code>unowned</code> 来修饰：</p>
<ul>
<li><p>当闭包和捕获的实例总是互相引用时并且总是同时销毁时，将闭包内的捕获定义为无主引用。</p>
</li>
<li><p>当捕获引用有时可能会是 <code>nil</code> 时，将闭包内的捕获定义为弱引用。弱引用总是可选类型，并且当引用的实例被销毁后，弱引用的值会自动置为 <code>nil</code>。这使我们可以在闭包内检查它们是否存在。</p>
</li>
</ul>
<blockquote>
<p>注意:<br>如果捕获的引用绝对不会置为 <code>nil</code>，应该用无主引用，而不是弱引用。</p>
</blockquote>
<p>在这个例子中，无主引用是正确的解决循环强引用的方法。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">HTMLElement</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">let</span> name: <span class="type">String</span></div><div class="line">    <span class="keyword">let</span> text: <span class="type">String</span>?</div><div class="line"></div><div class="line">    <span class="comment">// 这里，捕获列表是[unowned self]，表示“用无主引用而不是强引用来捕获self”。</span></div><div class="line">    <span class="built_in">lazy</span> <span class="keyword">var</span> asHTML: () -&gt; <span class="type">String</span> = &#123;</div><div class="line">        [<span class="keyword">unowned</span> <span class="keyword">self</span>] <span class="keyword">in</span></div><div class="line">        <span class="keyword">if</span> <span class="keyword">let</span> text = <span class="keyword">self</span>.text &#123;</div><div class="line">            <span class="keyword">return</span> <span class="string">"&lt;<span class="subst">\(<span class="keyword">self</span>.name)</span>&gt;<span class="subst">\(text)</span>&lt;/<span class="subst">\(<span class="keyword">self</span>.name)</span>&gt;"</span></div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">return</span> <span class="string">"&lt;<span class="subst">\(<span class="keyword">self</span>.name)</span> /&gt;"</span></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">init</span>(name: <span class="type">String</span>, text: <span class="type">String</span>? = <span class="literal">nil</span>) &#123;</div><div class="line">        <span class="keyword">self</span>.name = name</div><div class="line">        <span class="keyword">self</span>.text = text</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">deinit</span> &#123;</div><div class="line">        <span class="built_in">println</span>(<span class="string">"<span class="subst">\(name)</span> is being deinitialized"</span>)</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>和之前一样，我们可以创建并打印HTMLElement实例：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> paragraph: <span class="type">HTMLElement</span>? = <span class="type">HTMLElement</span>(name: <span class="string">"p"</span>, text: <span class="string">"hello, world"</span>)</div><div class="line"><span class="built_in">println</span>(paragraph!.asHTML())</div><div class="line"><span class="comment">// prints "&lt;p&gt;hello, world&lt;/p&gt;"</span></div></pre></td></tr></table></figure>
<p>使用捕获列表后引用关系如下图所示：</p>
<p><img src="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Art/closureReferenceCycle02_2x.png" alt=""></p>
<p>这一次，闭包以无主引用的形式捕获 <code>self</code>，并不会持有 <code>HTMLElement</code> 实例的强引用。如果将 <code>paragraph</code> 赋值为 <code>nil</code>，<code>HTMLElement</code> 实例将会被销毁，并能看到它的析构函数打印出的消息。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">paragraph = <span class="literal">nil</span></div><div class="line"><span class="comment">// prints "p is being deinitialized"</span></div></pre></td></tr></table></figure>
<h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>使用捕获列表来避免闭包的循环强引用。</p>
<ul>
<li><p>当闭包和捕获的实例总是互相引用时并且总是同时销毁时，将闭包内的捕获定义为无主引用。</p>
</li>
<li><p>当捕获引用有时可能会是 <code>nil</code> 时，将闭包内的捕获定义为弱引用。弱引用总是可选类型，并且当引用的实例被销毁后，弱引用的值会自动置为 <code>nil</code>。这使我们可以在闭包内检查它们是否存在。</p>
</li>
</ul>
<blockquote>
<p>注意:<br>如果捕获的引用绝对不会置为 <code>nil</code>，应该用无主引用，而不是弱引用。</p>
</blockquote>
<h2 id="Strong-Weak-Unowned-的区别"><a href="#Strong-Weak-Unowned-的区别" class="headerlink" title="Strong, Weak, Unowned 的区别"></a>Strong, Weak, Unowned 的区别</h2><p><img src="https://koenig-media.raywenderlich.com/uploads/2016/05/Table.png" alt=""></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&lt;code&gt;Swift&lt;/code&gt; 使用 &lt;code&gt;ARC(Automatic Reference Counting)&lt;/code&gt; 这一机制来跟踪和管理程序的内存使用状况。通常情况我们并不需要去考虑内存的管理，&lt;code&gt;ARC&lt;/code&gt; 机制会一直起作用，确保类的实例不再被使用时，可以自动释放其所占的内存。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;ARC&lt;/code&gt; 只会对引用类型起作用，结构体(Struct)和枚举类型(enum)是值类型，不是引用类型，也不是通过引用的方式存储和传递。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;然而在少数情况下，&lt;code&gt;ARC&lt;/code&gt; 需要我们提供更多的代码之间的信息来更好的管理内存，这篇文章则主要关注这些少数情况。&lt;/p&gt;
    
    </summary>
    
      <category term="编程" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="iOS" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B/iOS/"/>
    
      <category term="Swift" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B/iOS/Swift/"/>
    
    
      <category term="编程" scheme="http://yoursite.com/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="iOS" scheme="http://yoursite.com/tags/iOS/"/>
    
      <category term="Swift" scheme="http://yoursite.com/tags/Swift/"/>
    
      <category term="ARC" scheme="http://yoursite.com/tags/ARC/"/>
    
  </entry>
  
</feed>
